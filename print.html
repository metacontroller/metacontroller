<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Metacontroller</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Lightweight Kubernetes controllers as a service">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">1.2.</strong> Examples</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">1.3.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="features.html"><strong aria-hidden="true">1.4.</strong> Features</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">1.5.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="pronunciation.html"><strong aria-hidden="true">1.6.</strong> Pronunciation</a></li></ol></li><li class="chapter-item expanded "><a href="guide.html"><strong aria-hidden="true">2.</strong> User Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guide/install.html"><strong aria-hidden="true">2.1.</strong> Install Metacontroller</a></li><li class="chapter-item expanded "><a href="guide/helm-install.html"><strong aria-hidden="true">2.2.</strong> Install Metacontroller via helm</a></li><li class="chapter-item expanded "><a href="guide/configuration.html"><strong aria-hidden="true">2.3.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="guide/create.html"><strong aria-hidden="true">2.4.</strong> Create a controller</a></li><li class="chapter-item expanded "><a href="guide/best-practices.html"><strong aria-hidden="true">2.5.</strong> Constraints and best practices</a></li><li class="chapter-item expanded "><a href="guide/troubleshooting.html"><strong aria-hidden="true">2.6.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="api.html"><strong aria-hidden="true">3.</strong> API Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api/apply.html"><strong aria-hidden="true">3.1.</strong> Apply Semantics</a></li><li class="chapter-item expanded "><a href="api/compositecontroller.html"><strong aria-hidden="true">3.2.</strong> CompositeController</a></li><li class="chapter-item expanded "><a href="api/controllerrevision.html"><strong aria-hidden="true">3.3.</strong> ControllerRevision</a></li><li class="chapter-item expanded "><a href="api/decoratorcontroller.html"><strong aria-hidden="true">3.4.</strong> DecoratorController</a></li><li class="chapter-item expanded "><a href="api/customize.html"><strong aria-hidden="true">3.5.</strong> Customize Hook</a></li><li class="chapter-item expanded "><a href="api/hook.html"><strong aria-hidden="true">3.6.</strong> Hook</a></li></ol></li><li class="chapter-item expanded "><a href="design.html"><strong aria-hidden="true">4.</strong> Design Docs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/map-controller.html"><strong aria-hidden="true">4.1.</strong> MapController</a></li></ol></li><li class="chapter-item expanded "><a href="contrib.html"><strong aria-hidden="true">5.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contrib/build.html"><strong aria-hidden="true">5.1.</strong> Building</a></li><li class="chapter-item expanded "><a href="contrib/debug.html"><strong aria-hidden="true">5.2.</strong> Local development/debug</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Metacontroller</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/metacontroller/metacontroller" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Metacontroller is an add-on for <a href="https://kubernetes.io/">Kubernetes</a>
that makes it easy to write and deploy <a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/#custom-controllers">custom controllers</a>.
Although the <a href="https://www.github.com/metacontroller/metacontroller">open-source project</a> was started at Google,
the add-on works the same in any Kubernetes cluster.</p>
<p>While <a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/">custom resources</a>
provide <em>storage</em> for new types of objects, custom controllers define the <em>behavior</em>
of a new extension to the <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/">Kubernetes API</a>.
Just like the <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/">CustomResourceDefinition</a>
(CRD) API makes it easy to request storage for a custom resource,
the <a href="./api.html">Metacontroller APIs</a> make it easy to define behavior for a new extension API
or add custom behavior to existing APIs.</p>
<ul>
<li><a href="intro.html#simple-automation">Simple Automation</a></li>
<li><a href="intro.html#reusable-building-blocks">Reusable Building Blocks</a></li>
<li><a href="intro.html#complex-orchestration">Complex Orchestration</a></li>
<li><a href="intro.html#get-started">Get Started</a></li>
</ul>
<h2 id="simple-automation"><a class="header" href="#simple-automation">Simple Automation</a></h2>
<p>Kubernetes provides a lot of powerful automation through its built-in APIs,
but sometimes you just want to tweak one little thing or add a bit of logic on top.
With Metacontroller, you can write and deploy new <a href="https://hackernoon.com/level-triggering-and-reconciliation-in-kubernetes-1f17fe30333d">level-triggered</a>
API logic in minutes.</p>
<p>The code for your custom controller could be as simple as this example in <a href="http://jsonnet.org/">Jsonnet</a>
that <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/service-per-pod">adds a label to Pods</a>:</p>
<pre><code class="language-jsonnet">// This example is written in Jsonnet (a JSON templating language),
// but you can write hooks in any language.
function(request) {
  local pod = request.object,
  local labelKey = pod.metadata.annotations[&quot;pod-name-label&quot;],

  // Inject the Pod name as a label with the key requested in the annotation.
  labels: {
    [labelKey]: pod.metadata.name
  }
}
</code></pre>
<p>Since all you need to provide is a webhook that understands <a href="http://www.json.org/">JSON</a>,
you can use any programming language, often without any dependencies beyond the standard library.
The code above is not a snippet; it's the entire script.</p>
<p>You can quickly deploy your code through any <a href="https://en.wikipedia.org/wiki/Function_as_a_service">FaaS</a>
platform that offers HTTP(S) endpoints, or just <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/service-per-pod#deploy-the-decoratorcontrollers">load your script into a ConfigMap</a>
and launch a simple HTTP server to run it:</p>
<pre><code class="language-sh">kubectl create configmap service-per-pod-hooks -n metacontroller --from-file=hooks
</code></pre>
<p>Finally, you declaratively specify how your script interacts with the Kubernetes API,
which is analogous to writing a CustomResourceDefinition (to specify how to store objects):</p>
<pre><code class="language-yaml">apiVersion: metacontroller.k8s.io/v1alpha1
kind: DecoratorController
metadata:
  name: pod-name-label
spec:
  resources:
  - apiVersion: v1
    resource: pods
    annotationSelector:
      matchExpressions:
      - {key: pod-name-label, operator: Exists}
  hooks:
    sync:
      webhook:
        url: http://service-per-pod.metacontroller/sync-pod-name-label
</code></pre>
<p>This declarative specification means that your code never has to talk to the Kubernetes API,
so you don't need to import any Kubernetes client library nor depend on any code provided by
Kubernetes.
You merely receive JSON describing the observed state of the world
and return JSON describing your desired state.</p>
<p>Metacontroller remotely handles all interaction with the Kubernetes API.
It runs a level-triggered reconciliation loop on your behalf, much the way
CRD provides a declarative interface to request that the API Server
store objects on your behalf.</p>
<h2 id="reusable-building-blocks"><a class="header" href="#reusable-building-blocks">Reusable Building Blocks</a></h2>
<p>In addition to making ad hoc automation simple, Metacontroller also makes it
easier to build and compose general-purpose abstractions.</p>
<p>For example, many built-in workload APIs like <a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a>
are almost trivial to <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/catset">reimplement as Metacontroller hooks</a>,
meaning you can easily fork and customize such APIs.
Feature requests that used to take months to implement in the core Kubernetes
repository can be hacked together in an afternoon by anyone who wants them.</p>
<p>You can also compose existing APIs into higher-level abstractions,
such as how <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/bluegreen">BlueGreenDeployment</a>
builds on top of the <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a>
and <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> APIs.</p>
<p>Users can even invent new general-purpose APIs like <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/indexedjob">IndexedJob</a>,
which is a Job-like API that provides unique Pod identities like StatefulSet.</p>
<h2 id="complex-orchestration"><a class="header" href="#complex-orchestration">Complex Orchestration</a></h2>
<p>Extension APIs implemented with Metacontroller can also build on top of other
extension APIs that are themselves implemented with Metacontroller.
This pattern can be used to compose complex orchestration out of
simple building blocks that each do one thing well.</p>
<p>For example, the <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/vitess">Vitess Operator</a>
is implemented entirely as Jsonnet webhooks with Metacontroller.
The end result is much more complex than ad hoc automation or even
general-purpose workload abstractions, but the key is that this complexity
arises solely from the challenge of orchestrating <a href="https://vitess.io">Vitess</a>,
a distributed MySQL clustering system.</p>
<p>Building <a href="https://coreos.com/operators/">Operators</a> with Metacontroller
frees developers from learning the internal machinery of implementing
Kubernetes controllers and APIs, allowing them to focus on solving
problems in the application domain.
It also means they can take advantage of existing API machinery like
shared caches without having to write their Operators in Go.</p>
<p>Metacontroller's webhook APIs are designed to make it feel like you're
writing a one-shot, client-side generator that spits out JSON that gets
piped to <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#kubectl-apply"><code>kubectl apply</code></a>.</p>
<p>In other words, if you already know how to manually manage an application
in Kubernetes with <code>kubectl</code>, Metacontroller lets you write automation for
that app without having to learn a new language or how to use Kubernetes
client libraries.</p>
<h2 id="get-started"><a class="header" href="#get-started">Get Started</a></h2>
<ul>
<li><a href="./guide/install.html">Install Metacontroller</a></li>
<li><a href="./concepts.html">Learn concepts</a></li>
<li><a href="./examples.html">See examples</a></li>
<li><a href="./guide/create.html">Create a controller</a></li>
<li>Give feedback by filing <a href="https://www.github.com/metacontroller/metacontroller/issues">GitHub issues</a>.</li>
<li><a href="./contrib.html">Contribute</a>!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p>Metacontroller is an add-on for <a href="https://kubernetes.io/">Kubernetes</a>
that makes it easy to write and deploy <a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/#custom-controllers">custom controllers</a>.
Although the <a href="https://www.github.com/metacontroller/metacontroller">open-source project</a> was started at Google,
the add-on works the same in any Kubernetes cluster.</p>
<p>While <a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/">custom resources</a>
provide <em>storage</em> for new types of objects, custom controllers define the <em>behavior</em>
of a new extension to the <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/">Kubernetes API</a>.
Just like the <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/">CustomResourceDefinition</a>
(CRD) API makes it easy to request storage for a custom resource,
the <a href="./api.html">Metacontroller APIs</a> make it easy to define behavior for a new extension API
or add custom behavior to existing APIs.</p>
<ul>
<li><a href="intro.html#simple-automation">Simple Automation</a></li>
<li><a href="intro.html#reusable-building-blocks">Reusable Building Blocks</a></li>
<li><a href="intro.html#complex-orchestration">Complex Orchestration</a></li>
<li><a href="intro.html#get-started">Get Started</a></li>
</ul>
<h2 id="simple-automation-1"><a class="header" href="#simple-automation-1">Simple Automation</a></h2>
<p>Kubernetes provides a lot of powerful automation through its built-in APIs,
but sometimes you just want to tweak one little thing or add a bit of logic on top.
With Metacontroller, you can write and deploy new <a href="https://hackernoon.com/level-triggering-and-reconciliation-in-kubernetes-1f17fe30333d">level-triggered</a>
API logic in minutes.</p>
<p>The code for your custom controller could be as simple as this example in <a href="http://jsonnet.org/">Jsonnet</a>
that <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/service-per-pod">adds a label to Pods</a>:</p>
<pre><code class="language-jsonnet">// This example is written in Jsonnet (a JSON templating language),
// but you can write hooks in any language.
function(request) {
  local pod = request.object,
  local labelKey = pod.metadata.annotations[&quot;pod-name-label&quot;],

  // Inject the Pod name as a label with the key requested in the annotation.
  labels: {
    [labelKey]: pod.metadata.name
  }
}
</code></pre>
<p>Since all you need to provide is a webhook that understands <a href="http://www.json.org/">JSON</a>,
you can use any programming language, often without any dependencies beyond the standard library.
The code above is not a snippet; it's the entire script.</p>
<p>You can quickly deploy your code through any <a href="https://en.wikipedia.org/wiki/Function_as_a_service">FaaS</a>
platform that offers HTTP(S) endpoints, or just <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/service-per-pod#deploy-the-decoratorcontrollers">load your script into a ConfigMap</a>
and launch a simple HTTP server to run it:</p>
<pre><code class="language-sh">kubectl create configmap service-per-pod-hooks -n metacontroller --from-file=hooks
</code></pre>
<p>Finally, you declaratively specify how your script interacts with the Kubernetes API,
which is analogous to writing a CustomResourceDefinition (to specify how to store objects):</p>
<pre><code class="language-yaml">apiVersion: metacontroller.k8s.io/v1alpha1
kind: DecoratorController
metadata:
  name: pod-name-label
spec:
  resources:
  - apiVersion: v1
    resource: pods
    annotationSelector:
      matchExpressions:
      - {key: pod-name-label, operator: Exists}
  hooks:
    sync:
      webhook:
        url: http://service-per-pod.metacontroller/sync-pod-name-label
</code></pre>
<p>This declarative specification means that your code never has to talk to the Kubernetes API,
so you don't need to import any Kubernetes client library nor depend on any code provided by
Kubernetes.
You merely receive JSON describing the observed state of the world
and return JSON describing your desired state.</p>
<p>Metacontroller remotely handles all interaction with the Kubernetes API.
It runs a level-triggered reconciliation loop on your behalf, much the way
CRD provides a declarative interface to request that the API Server
store objects on your behalf.</p>
<h2 id="reusable-building-blocks-1"><a class="header" href="#reusable-building-blocks-1">Reusable Building Blocks</a></h2>
<p>In addition to making ad hoc automation simple, Metacontroller also makes it
easier to build and compose general-purpose abstractions.</p>
<p>For example, many built-in workload APIs like <a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a>
are almost trivial to <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/catset">reimplement as Metacontroller hooks</a>,
meaning you can easily fork and customize such APIs.
Feature requests that used to take months to implement in the core Kubernetes
repository can be hacked together in an afternoon by anyone who wants them.</p>
<p>You can also compose existing APIs into higher-level abstractions,
such as how <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/bluegreen">BlueGreenDeployment</a>
builds on top of the <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a>
and <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> APIs.</p>
<p>Users can even invent new general-purpose APIs like <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/indexedjob">IndexedJob</a>,
which is a Job-like API that provides unique Pod identities like StatefulSet.</p>
<h2 id="complex-orchestration-1"><a class="header" href="#complex-orchestration-1">Complex Orchestration</a></h2>
<p>Extension APIs implemented with Metacontroller can also build on top of other
extension APIs that are themselves implemented with Metacontroller.
This pattern can be used to compose complex orchestration out of
simple building blocks that each do one thing well.</p>
<p>For example, the <a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/vitess">Vitess Operator</a>
is implemented entirely as Jsonnet webhooks with Metacontroller.
The end result is much more complex than ad hoc automation or even
general-purpose workload abstractions, but the key is that this complexity
arises solely from the challenge of orchestrating <a href="https://vitess.io">Vitess</a>,
a distributed MySQL clustering system.</p>
<p>Building <a href="https://coreos.com/operators/">Operators</a> with Metacontroller
frees developers from learning the internal machinery of implementing
Kubernetes controllers and APIs, allowing them to focus on solving
problems in the application domain.
It also means they can take advantage of existing API machinery like
shared caches without having to write their Operators in Go.</p>
<p>Metacontroller's webhook APIs are designed to make it feel like you're
writing a one-shot, client-side generator that spits out JSON that gets
piped to <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#kubectl-apply"><code>kubectl apply</code></a>.</p>
<p>In other words, if you already know how to manually manage an application
in Kubernetes with <code>kubectl</code>, Metacontroller lets you write automation for
that app without having to learn a new language or how to use Kubernetes
client libraries.</p>
<h2 id="get-started-1"><a class="header" href="#get-started-1">Get Started</a></h2>
<ul>
<li><a href="./guide/install.html">Install Metacontroller</a></li>
<li><a href="./concepts.html">Learn concepts</a></li>
<li><a href="./examples.html">See examples</a></li>
<li><a href="./guide/create.html">Create a controller</a></li>
<li>Give feedback by filing <a href="https://www.github.com/metacontroller/metacontroller/issues">GitHub issues</a>.</li>
<li><a href="./contrib.html">Contribute</a>!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>This page lists some examples of what you can make with Metacontroller.</p>
<p>If you'd like to add a link to another example that demonstrates a new
language or technique, please send a pull request against
<a href="https://www.github.com/metacontroller/metacontroller/tree/master/docs/src/examples.md">this document</a>.</p>
<ul>
<li><a href="examples.html#compositecontroller">CompositeController</a>
<ul>
<li><a href="examples.html#catset-javascript">CatSet (JavaScript)</a></li>
<li><a href="examples.html#bluegreendeployment-javascript">BlueGreenDeployment (JavaScript)</a></li>
<li><a href="examples.html#indexedjob-python">IndexedJob (Python)</a></li>
</ul>
</li>
<li><a href="examples.html#decoratorcontroller">DecoratorController</a>
<ul>
<li><a href="examples.html#service-per-pod-jsonnet">Service Per Pod (Jsonnet)</a></li>
</ul>
</li>
<li><a href="examples.html#customize-hook-examples">Customize hook examples</a>
<ul>
<li><a href="examples.html#configmappropagation">ConfigMapPropagation</a></li>
<li><a href="examples.html#global-config-map">Global Config Map</a></li>
<li><a href="examples.html#secret-propagation">Secret propagation</a></li>
</ul>
</li>
</ul>
<h2 id="compositecontroller"><a class="header" href="#compositecontroller">CompositeController</a></h2>
<p><a href="./api/compositecontroller.html">CompositeController</a>
is an API provided by Metacontroller, designed to facilitate
custom controllers whose primary purpose is to manage a set of child objects
based on the desired state specified in a parent object.
Workload controllers like Deployment and StatefulSet are examples of existing
controllers that fit this pattern.</p>
<h3 id="catset-javascript"><a class="header" href="#catset-javascript">CatSet (JavaScript)</a></h3>
<p><a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/catset">CatSet</a> is a rewrite of
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a>,
including rolling updates, as a CompositeController.
It shows that existing workload controllers already use a pattern that could
fit within a CompositeController, namely managing child objects based on a
parent spec.</p>
<h3 id="bluegreendeployment-javascript"><a class="header" href="#bluegreendeployment-javascript">BlueGreenDeployment (JavaScript)</a></h3>
<p><a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/bluegreen">BlueGreenDeployment</a>
is an alternative to <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a>
that implements a <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">Blue-Green</a>
rollout strategy.
It shows how CompositeController can be used to add various automation on top
of built-in APIs like ReplicaSet.</p>
<h3 id="indexedjob-python"><a class="header" href="#indexedjob-python">IndexedJob (Python)</a></h3>
<p><a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/indexedjob">IndexedJob</a>
is an alternative to <a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/">Job</a>
that gives each Pod a unique index, like StatefulSet.
It shows how to write a CompositeController in Python, and also demonstrates
<a href="./api/compositecontroller.html#generate-selector">selector generation</a>.</p>
<h2 id="decoratorcontroller"><a class="header" href="#decoratorcontroller">DecoratorController</a></h2>
<p><a href="./api/decoratorcontroller.html">DecoratorController</a>
is an API provided by Metacontroller, designed to facilitate
adding new behavior to existing resources. You can define rules for which
resources to watch, as well as filters on labels and annotations.</p>
<p>For each object you watch, you can add, edit, or remove labels and annotations,
as well as create new objects and attach them. Unlike CompositeController,
these new objects don't have to match the main object's label selector.
Since they're attached to the main object, they'll be cleaned up automatically
when the main object is deleted.</p>
<h3 id="service-per-pod-jsonnet"><a class="header" href="#service-per-pod-jsonnet">Service Per Pod (Jsonnet)</a></h3>
<p><a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/service-per-pod">Service Per Pod</a>
is an example DecoratorController that creates an individual Service for
every Pod in a StatefulSet (e.g. to give them static IPs), effectively adding
new behavior to StatefulSet without having to reimplement it.</p>
<h2 id="customize-hook-examples"><a class="header" href="#customize-hook-examples">Customize hook examples</a></h2>
<p><a href="./api/customize.html">Customize hook</a> is addition to Composite/Decorator controllers, extending information given in <code>sync</code> hook of other objects (called <code>related</code>) in addition to parent.</p>
<h3 id="configmappropagation"><a class="header" href="#configmappropagation">ConfigMapPropagation</a></h3>
<p><a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/configmappropagation">ConfigMapPropagation</a> is
a simple mechanism to propagate given <code>ConfigMap</code> to other namespaces, specified in given objects. Source <code>ConfigMap</code> is also specified.
This is also an example how <code>Status</code> subresource should be handled.</p>
<h3 id="global-config-map"><a class="header" href="#global-config-map">Global Config Map</a></h3>
<p><a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/globalconfigmap">Global Config Map</a> is similar to <code>ConfigMapPropagation</code>. but populates <code>ConfigMap</code> to all namespaces.</p>
<h3 id="secret-propagation"><a class="header" href="#secret-propagation">Secret propagation</a></h3>
<p><a href="https://www.github.com/metacontroller/metacontroller/tree/master/examples/secretpropagation">Secret propagation</a> is modyfication of <code>ConfigMapPropagation</code> concept, 
using label selector on <code>Namespace</code> object to choose where to
propagate <code>Secret</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>This page provides some background on terms that are used throughout
the Metacontroller documentation.</p>
<ul>
<li><a href="concepts.html#kubernetes-concepts">Kubernetes Concepts</a>
<ul>
<li><a href="concepts.html#resource">Resource</a>
<ul>
<li><a href="concepts.html#resource-name">Resource Name</a></li>
<li><a href="concepts.html#api-group">API Group</a></li>
<li><a href="concepts.html#api-version">API Version</a></li>
<li><a href="concepts.html#api-kind">API Kind</a></li>
</ul>
</li>
<li><a href="concepts.html#custom-resource">Custom Resource</a></li>
<li><a href="concepts.html#controller">Controller</a></li>
<li><a href="concepts.html#custom-controller">Custom Controller</a></li>
</ul>
</li>
<li><a href="concepts.html#metacontroller-concepts">Metacontroller Concepts</a>
<ul>
<li><a href="concepts.html#metacontroller">Metacontroller</a></li>
<li><a href="concepts.html#lambda-controller">Lambda Controller</a></li>
<li><a href="concepts.html#lambda-hook">Lambda Hook</a></li>
</ul>
</li>
</ul>
<h2 id="kubernetes-concepts"><a class="header" href="#kubernetes-concepts">Kubernetes Concepts</a></h2>
<p>These are some of the general <a href="https://kubernetes.io/docs/concepts/">Kubernetes Concepts</a>
that are particularly relevant to Metacontroller.</p>
<h3 id="resource"><a class="header" href="#resource">Resource</a></h3>
<p>In the context of the <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/">Kubernetes API</a>, a <em>resource</em> is a <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a>-style
collection of <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/">API objects</a>.
When writing controllers, it's important to understand the following terminology.</p>
<h4 id="resource-name"><a class="header" href="#resource-name">Resource Name</a></h4>
<p>There are many ways to refer to a resource.
For example, you may have noticed that you can fetch ReplicaSets with
any of the following commands:</p>
<pre><code class="language-sh">kubectl get rs          # short name
kubectl get replicaset  # singular name
kubectl get replicasets # plural name
</code></pre>
<p>When writing controllers, it's important to note that the <em>plural name</em>
is the canonical form when interacting with the REST API
(it's in the URL) and API discovery (entries are keyed by plural name).</p>
<p>So, whenever Metacontroller asks for a resource name, you should use the
canonical, lowercase, plural form (e.g. <code>replicasets</code>).</p>
<h4 id="api-group"><a class="header" href="#api-group">API Group</a></h4>
<p>Each resource lives inside a particular <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-groups">API group</a>, which helps different
API authors avoid name conflicts.
For example, you can have two resources with the same name as long as they are
in different API groups.</p>
<h4 id="api-version"><a class="header" href="#api-version">API Version</a></h4>
<p>Each API group has one or more available <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-versioning">API versions</a>.
It's important to note that Kubernetes API versions are <a href="https://cloudplatform.googleblog.com/2018/03/API-design-which-version-of-versioning-is-right-for-you.html">format versions</a>.
That is, each version is a different lens through which you can view objects in the collection,
but you'll see the same set of underlying objects no matter which lens you view them through.</p>
<p>The API group and version are often combined in the form <code>&lt;group&gt;/&lt;version&gt;</code>,
such as in the <code>apiVersion</code> field of an API object.
APIs in the <em>core</em> group (like Pod) omit the group name in such cases,
specifying only <code>&lt;version&gt;</code>.</p>
<h4 id="api-kind"><a class="header" href="#api-kind">API Kind</a></h4>
<p>Whereas a <em>resource</em> is a collection of objects served at a particular REST path,
the <em>kind</em> of a resource represents something like the <em>type</em> or <em>class</em> of those
objects.</p>
<p>Since Kubernetes resources and kinds must have a 1-to-1 correspondence within
a given API group, the resource name and kind are often used interchangeably
in Kubernetes documentation.
However, it's important to distinguish the resource and kind when writing
controllers.</p>
<p>The kind is often the same as the singular resource name, except that it's
written in UpperCamelCase.
This is the form that you use when writing JSON or YAML manifests,
and so it's also the form you should use when generating objects within a
<a href="concepts.html#lambda-hook">lambda hook</a>:</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: ReplicaSet
[...]
</code></pre>
<h3 id="custom-resource"><a class="header" href="#custom-resource">Custom Resource</a></h3>
<p>A <a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/">custom resource</a> is any <a href="concepts.html#resource">resource</a> that's installed through
dynamic API registration (either through CRD or aggregation),
rather than by being compiled directly into the Kubernetes API server.</p>
<h3 id="controller"><a class="header" href="#controller">Controller</a></h3>
<p>Distributed components in the Kubernetes control plane communicate with each
other by posting records in a shared datastore (like a public message board),
rather than sending direct messages (like email).</p>
<p>This design helps avoid silos of information. All participants can see what
everyone is saying to everyone else, so each participant can easily access
whatever information it needs to make the best decision, even as those needs change.
The lack of silos also means extensions have the same power as built-in features.</p>
<p>In the context of the Kubernetes control plane, a <em>controller</em> is a
long-running, automated, autonomous agent that participates in the
control plane via this shared datastore (the Kubernetes API server).
In the message board analogy, you can think of controllers like bots.</p>
<p>A given controller might participate by:</p>
<ul>
<li>observing objects in the API server as inputs and
creating or updating other objects in the API server as outputs
(e.g. creating Pods for a ReplicaSet);</li>
<li>observing objects in the API server as inputs
and taking action in some other domain
(e.g. spawning containers for a Pod);</li>
<li>creating or updating objects in the API server
to report observations from some other domain
(e.g. &quot;the container is running&quot;);</li>
<li>or any combination of the above.</li>
</ul>
<h3 id="custom-controller"><a class="header" href="#custom-controller">Custom Controller</a></h3>
<p>A <a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/#custom-controllers">custom controller</a> is any <a href="concepts.html#controller">controller</a> that can be installed,
upgraded, and removed in a running cluster, independently of the cluster's own
lifecycle.</p>
<h2 id="metacontroller-concepts"><a class="header" href="#metacontroller-concepts">Metacontroller Concepts</a></h2>
<p>These are some concepts that are specific to Metacontroller.</p>
<h3 id="metacontroller"><a class="header" href="#metacontroller">Metacontroller</a></h3>
<p><em>Metacontroller</em> is a server that extends Kubernetes with APIs that encapsulate
the common parts of writing <a href="concepts.html#custom-controller">custom controllers</a>.</p>
<p>Just like <a href="https://kubernetes.io/docs/concepts/overview/components/#kube-controller-manager">kube-controller-manager</a>, this server hosts multiple controllers.
However, the set of hosted controllers changes dynamically in response to
updates in objects of the Metacontroller API types.
Metacontroller is thus itself a controller that watches the Metacontroller API
objects and launches hosted controllers in response.
In other words, it's a controller-controller -- hence the name.</p>
<h3 id="lambda-controller"><a class="header" href="#lambda-controller">Lambda Controller</a></h3>
<p>When you create a controller with one of the Metacontroller APIs, you provide
a function that contains only the business logic specific to your controller.
Since these functions are called via webhooks, you can write them in any
language that can understand HTTP and JSON, and optionally host them with
a Functions-as-a-Service provider.</p>
<p>The Metacontroller server then executes a control loop on your behalf,
calling your function whenever necessary to decide what to do.</p>
<p>These callback-based controllers are called <em>lambda controllers</em>.
To keep the interface as simple as possible, each lambda controller API targets
a specific controller pattern, such as:</p>
<ul>
<li><a href="./api/compositecontroller.html">CompositeController</a>: <em>objects composed of other objects</em></li>
<li><a href="./api/decoratorcontroller.html">DecoratorController</a>: <em>attach new behavior to existing objects</em></li>
</ul>
<p>Support for other types of controller patterns will be added in the future,
such as coordinating between Kubernetes API objects and external state
in another domain.</p>
<h3 id="lambda-hook"><a class="header" href="#lambda-hook">Lambda Hook</a></h3>
<p>Each <a href="concepts.html#lambda-controller">lambda controller</a> API defines a set of hooks,
which it calls to let you implement your business logic.</p>
<p>Currently, these <a href="./api/hook.html">lambda hooks</a> must be implemented as webhooks,
but other mechanisms could be added in the future,
such as gRPC or embedded scripting languages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>This is a high-level overview of what Metacontroller provides
for Kubernetes controller authors.</p>
<ul>
<li><a href="features.html#dynamic-scripting">Dynamic Scripting</a></li>
<li><a href="features.html#controller-best-practices">Controller Best Practices</a></li>
<li><a href="features.html#declarative-watches">Declarative Watches</a></li>
<li><a href="features.html#declarative-reconciliation">Declarative Reconciliation</a></li>
<li><a href="features.html#declarative-declarative-rolling-update">Declarative Declarative Rolling Update</a></li>
</ul>
<h2 id="dynamic-scripting"><a class="header" href="#dynamic-scripting">Dynamic Scripting</a></h2>
<p>With Metacontroller's <a href="./concepts.html#lambda-controller">hook-based design</a>, you can write <a href="./concepts.html#controller">controllers</a>
in any language while still taking advantage of the efficient machinery we
developed in Go for core controllers.</p>
<p>This makes Metacontroller especially useful for rapid development
of automation in dynamic scripting languages like Python or JavaScript,
although you're also free to use statically-typed languages like Go or Java.</p>
<p>To support fast ramp-up and iteration on your ideas,
Metacontroller makes it possible to write controllers with:</p>
<ul>
<li>No schema/IDL</li>
<li>No generated code</li>
<li>No library dependencies</li>
<li>No container image build/push</li>
</ul>
<h2 id="controller-best-practices"><a class="header" href="#controller-best-practices">Controller Best Practices</a></h2>
<p>Controllers you write with Metacontroller automatically behave like
first-class citizens out of the box, before you write any code.</p>
<p>All interaction with the Kubernetes API happens inside the Metacontroller
server in response to your instructions.
This allows Metacontroller to implement best practices learned from writing
core controllers without polluting your business logic.</p>
<p>Even the simplest <a href="./guide/create.html">Hello, World</a> example with Metacontroller
already takes care of:</p>
<ul>
<li>Label selectors (for defining flexible collections of objects)</li>
<li>Orphan/adopt semantics (controller reference)</li>
<li>Garbage collection (owner references for automatic cleanup)</li>
<li>Watches (for low latency)</li>
<li>Caching (shared informers/reflectors/listers)</li>
<li>Work queues (deduplicated parallelism)</li>
<li>Optimistic concurrency (resource version)</li>
<li>Retries with exponential backoff</li>
<li>Periodic relist/resync</li>
</ul>
<h2 id="declarative-watches"><a class="header" href="#declarative-watches">Declarative Watches</a></h2>
<p>Rather than writing boilerplate code for each type of <a href="./concepts.html#resource">resource</a>
you want to watch, you simply list those resources declaratively:</p>
<pre><code class="language-yaml">childResources:
- apiVersion: v1
  resource: pods
- apiVersion: v1
  resource: persistentvolumeclaims
</code></pre>
<p>Behind the scenes, Metacontroller sets up watch streams that are shared across
all controllers that use Metacontroller.</p>
<p>That means, for example, that you can create as many <a href="./concepts.html#lambda-controller">lambda controllers</a>
as you want that watch Pods, and the API server will only need to send one Pod
watch stream (to Metacontroller itself).</p>
<p>Metacontroller then acts like a demultiplexer, determining which controllers will
care about a given event in the stream and triggering their hooks only as needed.</p>
<h2 id="declarative-reconciliation"><a class="header" href="#declarative-reconciliation">Declarative Reconciliation</a></h2>
<p>A large part of the expressiveness of the Kubernetes API is due to its focus on
declarative management of cluster state, which lets you directly specify an
end state without specifying how to get there.
Metacontroller expands on this philosophy, allowing you to define controllers
in terms of what they want without specifying how to get there.</p>
<p>Instead of thinking about imperative operations like create/read/update/delete,
you just generate a list of all the things you want to exist.
Based on the current cluster state, Metacontroller will then determine what
actions are required to move the cluster towards your desired state and
maintain it once its there.</p>
<p>Just like the built-in controllers, the reconciliation that Metacontroller
performs for you is <a href="https://hackernoon.com/level-triggering-and-reconciliation-in-kubernetes-1f17fe30333d">level-triggered</a> so it's resilient to downtime
(missed events), yet optimized for low latency and low API load through shared
watches and caches.</p>
<p>However, the clear separation of <em>deciding what you want</em> (the hook you write)
from <em>running a low-latency, level-triggered reconciliation loop</em>
(what Metacontroller does for you) means you don't have to think about this.</p>
<h2 id="declarative-declarative-rolling-update"><a class="header" href="#declarative-declarative-rolling-update">Declarative Declarative Rolling Update</a></h2>
<p>Another big contributor to the power of Kubernetes APIs like Deployment and
StatefulSet is the ability to declaratively specify gradual state transitions.
When you update your app's container image or configuration, for example, these
controllers will slowly roll out Pods with the new template and automatically
pause if things don't look right.</p>
<p>Under the hood, implementing gradual state transitions with level-triggered
reconcilation loops involves careful bookkeeping with auxilliary records,
which is why StatefulSet originally launched without rolling updates.
Metacontroller lets you easily build your own APIs that offer declarative
rolling updates without making you think about all this additional bookkeeping.</p>
<p>In fact, Metacontroller provides a declarative interface for configuring how
you want to implement declarative rolling updates in your controller
(<em>declarative declarative rolling update</em>),
so you don't have to write any code to take advantage of this feature.</p>
<p>For example, <a href="https://www.github.com/GoogleCloudPlatform/metacontroller/pull/22/files">adding support for rolling updates</a>
to a Metacontroller-based <a href="./examples.html#catset-javascript">rewrite of StatefulSet</a>
looks essentially like this:</p>
<pre><code class="language-diff">   childResources:
   - apiVersion: v1
     resource: pods
+    updateStrategy:
+      method: RollingRecreate
+      statusChecks:
+        conditions:
+        - type: Ready
+          status: &quot;True&quot;
</code></pre>
<p>For comparison, the corresponding pull request to
<a href="https://github.com/kubernetes/kubernetes/pull/46669">add rolling updates to StatefulSet itself</a> involved
over 9,000 lines of changes to business logic, boilerplate, and generated code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<p>This page answers some common questions encountered while
evaluating, setting up, and using Metacontroller.</p>
<p>If you have any questions that aren't answered here,
please ask on the <a href="https://groups.google.com/forum/#!forum/metacontroller">mailing list</a>
or <a href="https://kubernetes.slack.com/messages/metacontroller/">Slack channel</a>.</p>
<ul>
<li><a href="faq.html#evaluating-metacontroller">Evaluating Metacontroller</a>
<ul>
<li><a href="faq.html#how-does-metacontroller-compare-with-other-tools">How does Metacontroller compare with other tools?</a></li>
<li><a href="faq.html#what-is-metacontroller-good-for">What is Metacontroller good for?</a></li>
<li><a href="faq.html#what-is-metacontroller-not-good-for">What is Metacontroller not good for?</a></li>
<li><a href="faq.html#do-i-have-to-use-crd">Do I have to use CRD?</a></li>
<li><a href="faq.html#what-does-the-name-metacontroller-mean">What does the name Metacontroller mean?</a></li>
<li><a href="faq.html#how-do-you-pronounce-metacontroller">How do you pronounce Metacontroller?</a></li>
</ul>
</li>
<li><a href="faq.html#setting-up-metacontroller">Setting Up Metacontroller</a>
<ul>
<li><a href="faq.html#do-i-need-to-be-a-cluster-admin-to-install-metacontroller">Do I need to be a cluster admin to install Metacontroller?</a></li>
<li><a href="faq.html#why-is-metacontroller-shared-cluster-wide">Why is Metacontroller shared cluster-wide?</a></li>
<li><a href="faq.html#why-does-metacontroller-need-these-permissions">Why does Metacontroller need these permissions?</a></li>
<li><a href="faq.html#does-metacontroller-have-to-be-in-its-own-namespace">Does Metacontroller have to be in its own namespace?</a></li>
</ul>
</li>
<li><a href="faq.html#developing-with-metacontroller">Developing with Metacontroller</a>
<ul>
<li><a href="faq.html#which-languages-can-i-write-hooks-in">Which languages can I write hooks in?</a></li>
<li><a href="faq.html#how-do-i-access-the-kubernetes-api-from-my-hook">How do I access the Kubernetes API from my hook?</a></li>
<li><a href="faq.html#can-i-call-external-apis-from-my-hook">Can I call external APIs from my hook?</a></li>
<li><a href="faq.html#how-can-i-make-sure-external-resources-get-cleaned-up">How can I make sure external resources get cleaned up?</a></li>
<li><a href="faq.html#does-metacontroller-support-apply-semantics">Does Metacontroller support &quot;apply&quot; semantics?</a></li>
<li><a href="faq.html#how-do-i-host-my-hook">How do I host my hook?</a></li>
<li><a href="faq.html#how-can-i-provide-a-programmatic-client-for-my-api">How can I provide a programmatic client for my API?</a></li>
<li><a href="faq.html#what-are-the-best-practices-for-designing-controllers">What are the best practices for designing controllers?</a></li>
<li><a href="faq.html#how-do-i-troubleshoot-problems">How do I troubleshoot problems?</a></li>
</ul>
</li>
</ul>
<h2 id="evaluating-metacontroller"><a class="header" href="#evaluating-metacontroller">Evaluating Metacontroller</a></h2>
<h3 id="how-does-metacontroller-compare-with-other-tools"><a class="header" href="#how-does-metacontroller-compare-with-other-tools">How does Metacontroller compare with other tools?</a></h3>
<p>See the <a href="./features.html">features</a> page for a list of the things that are
most unique about Metacontroller's approach.</p>
<p>In general, Metacontroller aims to make common patterns as simple as possible,
without necessarily supporting the full flexibility you would have if you wrote
a controller from scratch.
The philosophy is analogous to that of <a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/#customresourcedefinitions">CustomResourceDefinition</a> (CRD),
where the main API server does all the heavy lifting for you, but you don't have
as much control as you would if you wrote your own API server and connected it
through <a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/#api-server-aggregation">aggregation</a>.</p>
<p>Just like CRD, Metacontroller started with a small set of capabilities and is
expanding over time to support more customization and more use cases as we gain
confidence in the abstractions.
Depending on your use case, you may prefer one of the alternative tools that
took the opposite approach of first allowing everything and then building
&quot;rails&quot; over time to encourage best practices and simplify development.</p>
<h3 id="what-is-metacontroller-good-for"><a class="header" href="#what-is-metacontroller-good-for">What is Metacontroller good for?</a></h3>
<p>Metacontroller is intended to be a generic tool for creating many kinds of
Kubernetes <a href="./concepts.html#controller">controllers</a>, but one of its earliest motivating use cases was to
simplify development of custom workload automation, so it's particularly
well-suited for this.</p>
<p>For example, if you've ever thought, &quot;I wish StatefulSet would do this one
thing differently,&quot; Metacontroller gives you the tools to <a href="./examples.html#catset-javascript">define your own
custom behavior</a> without reinventing the wheel.</p>
<p>Metacontroller is also well-suited to people who prefer languages other than
Go, but still want to benefit from the efficient API machinery that was
developed in Go for the core Kubernetes controllers.</p>
<p>Lastly, Metacontroller is good for rapid development of automation on top of
APIs that already exist as Kubernetes resources, such as:</p>
<ul>
<li>ad hoc scripting (&quot;make an X for every Y&quot;)</li>
<li>configuration abstraction (&quot;when I say A, that means {X,Y,Z}&quot;)</li>
<li>higher-level automation of custom APIs added by <a href="https://coreos.com/operators/">Operators</a></li>
<li>gluing an <a href="faq.html#can-i-call-external-apis-from-my-hook">external CRUD API</a> into the Kubernetes control plane with a
simple translation layer</li>
</ul>
<h3 id="what-is-metacontroller-not-good-for"><a class="header" href="#what-is-metacontroller-not-good-for">What is Metacontroller not good for?</a></h3>
<p>Metacontroller is not a good fit when you need to examine a large number of
objects to answer a single hook request.
For example, if you need to be sent a list of all Pods or all Nodes in order to
decide on your desired state, we'd have to call your hook with the full list of
all Pods or Nodes any time any one of them changed.
However, it might be a good fit if your desired behavior can be naturally
broken down into per-Pod or per-Node tasks, since then we'd only need to call
your hook with each object that changed.</p>
<p>Metacontroller is also not a good fit for writing controllers that perform long
sequences of imperative steps -- for example, a single hook that executes many
steps of a workflow by creating various children at the right times.
That's because Metacontroller hooks work best when they use a functional style
(no side effects, and output depends only on input), which is an awkward style
for defining imperative sequences.</p>
<h3 id="do-i-have-to-use-crd"><a class="header" href="#do-i-have-to-use-crd">Do I have to use CRD?</a></h3>
<p>It's common to use <a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/#customresourcedefinitions">CRD</a>, but Metacontroller doesn't know or care whether a
<a href="./concepts.html#resource">resource</a> is built-in or <a href="./concepts.html#custom-resource">custom</a>, nor whether it's served
by CRD or by an <a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/#api-server-aggregation">aggregated API server</a>.</p>
<p>Metacontroller uses API discovery and the dynamic client to treat all resources
the same, so you can write automation for any type of resource.
Using the dynamic client also means Metacontroller doesn't need to be updated
when new APIs or fields are added in subsequent Kubernetes releases.</p>
<h3 id="what-does-the-name-metacontroller-mean"><a class="header" href="#what-does-the-name-metacontroller-mean">What does the name Metacontroller mean?</a></h3>
<p>The name <em>Metacontroller</em> comes from the English words <em>meta</em> and <em>controller</em>.
Metacontroller is a <em>controller controller</em> --
a <a href="./concepts.html#controller">controller</a> that controls other controllers.</p>
<h3 id="how-do-you-pronounce-metacontroller"><a class="header" href="#how-do-you-pronounce-metacontroller">How do you pronounce Metacontroller?</a></h3>
<p>Please see the <a href="./pronunciation.html">pronunciation guide</a>.</p>
<h2 id="setting-up-metacontroller"><a class="header" href="#setting-up-metacontroller">Setting Up Metacontroller</a></h2>
<h3 id="do-i-need-to-be-a-cluster-admin-to-install-metacontroller"><a class="header" href="#do-i-need-to-be-a-cluster-admin-to-install-metacontroller">Do I need to be a cluster admin to install Metacontroller?</a></h3>
<p><a href="./guide/install.html">Installing Metacontroller</a> requires permission to both install
<a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/#customresourcedefinitions">CRDs</a> (representing the <a href="./api.html">Metacontroller APIs</a> themselves)
and grant permissions for Metacontroller to access other resources on
behalf of the controllers it hosts.</p>
<h3 id="why-is-metacontroller-shared-cluster-wide"><a class="header" href="#why-is-metacontroller-shared-cluster-wide">Why is Metacontroller shared cluster-wide?</a></h3>
<p>Metacontroller currently only supports cluster-wide installation
because it's modeled after the built-in <a href="https://kubernetes.io/docs/concepts/overview/components/#kube-controller-manager">kube-controller-manager</a>
component to achieve the same benefits of sharing watches and caches.</p>
<p>Also, resources in general (either built-in or custom) can only be
installed cluster-wide, and a Kubernetes API object is conventionally
intended to mean the same thing regardless of what namespace it's in.</p>
<h3 id="why-does-metacontroller-need-these-permissions"><a class="header" href="#why-does-metacontroller-need-these-permissions">Why does Metacontroller need these permissions?</a></h3>
<p>During alpha, Metacontroller simply requests wildcard permission to all
resources so the controllers it hosts can access anything they want.
For this reason, you should only give trusted users access to the
<a href="./api.html">Metacontroller APIs</a> that create hosted controllers.</p>
<p>By contrast, core controllers are restricted to only the minimal set of
permissions needed to do their jobs.</p>
<!---As part of the [beta roadmap][roadmap], we plan to offer per-controller
service accounts to mitigate the risks of confused deputy problems.

[roadmap]: https://www.github.com/metacontroller/metacontroller/issues/9-->
<h3 id="does-metacontroller-have-to-be-in-its-own-namespace"><a class="header" href="#does-metacontroller-have-to-be-in-its-own-namespace">Does Metacontroller have to be in its own namespace?</a></h3>
<p>The default installation manifests put Metacontroller in its own namespace
to make it easy to see what's there and clean up if necessary,
but it can run anywhere.
The <code>metacontroller</code> namespace is also used in <a href="./examples.html">examples</a> for similar
convenience reasons, but you can run webhooks in any namespace
or even host them outside the cluster.</p>
<h2 id="developing-with-metacontroller"><a class="header" href="#developing-with-metacontroller">Developing with Metacontroller</a></h2>
<h3 id="which-languages-can-i-write-hooks-in"><a class="header" href="#which-languages-can-i-write-hooks-in">Which languages can I write hooks in?</a></h3>
<p>You can write <a href="./concepts.html#lambda-hook">lambda hooks</a> (the business logic for your controller)
in any language, as long as you can host it as a webhook that accepts
and returns JSON.
Regardless of which language you use for your business logic,
Metacontroller uses the efficient machinery written in Go for the
core controllers to interact with the API server on your behalf.</p>
<h3 id="how-do-i-access-the-kubernetes-api-from-my-hook"><a class="header" href="#how-do-i-access-the-kubernetes-api-from-my-hook">How do I access the Kubernetes API from my hook?</a></h3>
<p>You don't! Or at least, you don't have to, and it's best not to.
Instead, you just <a href="./features.html#declarative-watches">declare what objects you care about</a>
and Metacontroller will send them to you as part of the hook request.
Then, your hook should simply return a list of desired objects.
Metacontroller will take care of <a href="./features.html#declarative-reconciliation">reconciling your desired state</a>.</p>
<h3 id="can-i-call-external-apis-from-my-hook"><a class="header" href="#can-i-call-external-apis-from-my-hook">Can I call external APIs from my hook?</a></h3>
<p>Yes. Your hook code can do whatever it wants as part of computing a response to
a Metacontroller hook request, including calling external APIs.</p>
<p>The main thing to be careful of is to avoid synchronously waiting for
long-running tasks to finish, since that will hold up one of a fixed number of
concurrent slots in the queue of triggers for that hook.
Instead, if your hook needs to wait for some condition that's checked through an
external API, you should return a status that indicates this pending state,
and set a <a href="./api/compositecontroller.html#resync-period">resync period</a> so you get a chance to check the condition again
later.</p>
<h3 id="how-can-i-make-sure-external-resources-get-cleaned-up"><a class="header" href="#how-can-i-make-sure-external-resources-get-cleaned-up">How can I make sure external resources get cleaned up?</a></h3>
<p>If you allocate external resources as part of your hook, you should also
implement a <a href="./api/compositecontroller.html#finalize-hook">finalize hook</a> to make sure you get a chance to clean up those
external resources when the Kubernetes API object for which you created them
goes away.</p>
<h3 id="does-metacontroller-support-apply-semantics"><a class="header" href="#does-metacontroller-support-apply-semantics">Does Metacontroller support &quot;apply&quot; semantics?</a></h3>
<p>Yes, Metacontroller enforces <a href="./api/apply.html">apply semantics</a>, which means your controller
will play nicely with other automation as long as you only fill in the fields
that you care about in the objects you return.</p>
<h3 id="how-do-i-host-my-hook"><a class="header" href="#how-do-i-host-my-hook">How do I host my hook?</a></h3>
<p>You can host your <a href="./concepts.html#lambda-hook">lambda hooks</a> with an HTTP server library in your chosen
language, with a standalone HTTP server, or with a Functions-as-a-Service platform.
See the <a href="./examples.html">examples</a> page for approaches in various languages.</p>
<h3 id="how-can-i-provide-a-programmatic-client-for-my-api"><a class="header" href="#how-can-i-provide-a-programmatic-client-for-my-api">How can I provide a programmatic client for my API?</a></h3>
<p>Since Metacontroller uses the dynamic client on your behalf, you can write your
controller's business logic without any client library at all.
That also means you can write a &quot;dynamically typed&quot; controller without creating
static schema (either Kubernetes' Go IDL or OpenAPI) or generating a client.</p>
<p>However, if you want to provide a static client for users of your API,
nothing about Metacontroller prevents you from writing Go IDL or OpenAPI
and generating a client the same way you would without Metacontroller.</p>
<h3 id="what-are-the-best-practices-for-designing-controllers"><a class="header" href="#what-are-the-best-practices-for-designing-controllers">What are the best practices for designing controllers?</a></h3>
<p>Please see the dedicated <a href="./guide/best-practices.html">best practices guide</a>.</p>
<h3 id="how-do-i-troubleshoot-problems"><a class="header" href="#how-do-i-troubleshoot-problems">How do I troubleshoot problems?</a></h3>
<p>Please see the dedicated <a href="./guide/troubleshooting.html">troubleshooting guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-pronounce-metacontroller"><a class="header" href="#how-to-pronounce-metacontroller">How to pronounce Metacontroller</a></h1>
<p><em>Metacontroller</em> is pronounced as <em>me-ta-con-trol-ler</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-guide"><a class="header" href="#user-guide">User Guide</a></h1>
<p>This section contains general tips and step-by-step tutorials for using Metacontroller.</p>
<p>See the <a href="./api.html">API Reference</a> for details about all the available options.</p>
<h2 id="installation"><a class="header" href="#installation"><a href="./guide/install.html">Installation</a></a></h2>
<p>This page describes how to install Metacontroller, either to develop your own
controllers or just to run third-party controllers that depend on it.</p>
<h2 id="create-a-controller"><a class="header" href="#create-a-controller"><a href="./guide/create.html">Create a Controller</a></a></h2>
<p>This tutorial walks through a simple example of creating a controller in Python
with Metacontroller.</p>
<h2 id="best-practices"><a class="header" href="#best-practices"><a href="./guide/best-practices.html">Best Practices</a></a></h2>
<p>Metacontroller will take care of merging your change to <code>importantField</code> while
preserving the fields you don't care about that were set by others.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting"><a href="./guide/troubleshooting.html">Troubleshooting</a></a></h2>
<p>This is a collection of tips for debugging controllers written with Metacontroller.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-1"><a class="header" href="#installation-1">Installation</a></h1>
<p>This page describes how to install Metacontroller, either to develop your own
controllers or just to run third-party controllers that depend on it.</p>
<ul>
<li><a href="guide/install.html#docker-images">Docker images</a></li>
<li><a href="guide/install.html#prerequisites">Prerequisites</a>
<ul>
<li><a href="guide/install.html#grant-yourself-cluster-admin-gke-only">Grant yourself cluster-admin (GKE only)</a></li>
</ul>
</li>
<li><a href="guide/install.html#install-metacontroller-using-kustomize">Install Metacontroller using Kustomize</a></li>
<li><a href="guide/install.html#install-metacontroller-using-helm">Install Metacontroller using Helm</a></li>
<li><a href="guide/install.html#migrating-from-googlecloudplatformmetacontroller">Migrating from /GoogleCloudPlatform/metacontroller</a></li>
</ul>
<h2 id="docker-images"><a class="header" href="#docker-images">Docker images</a></h2>
<p>Images are hosted in two places:</p>
<ul>
<li><a href="https://hub.docker.com/r/metacontrollerio/metacontroller">dockerhub</a></li>
<li><a href="https://github.com/metacontroller/metacontroller/pkgs/container/metacontroller">ghcr.io</a></li>
</ul>
<p>Feel free to use whatever suits your need, they identical. Note - currently in <code>helm</code> charts the dockerhub one's are used. </p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Kubernetes v1.17+ (because of maintainability, e2e test suite might not cover all releases)</li>
<li>You should have <code>kubectl</code> available and configured to talk to the desired cluster.</li>
</ul>
<h3 id="grant-yourself-cluster-admin-gke-only"><a class="header" href="#grant-yourself-cluster-admin-gke-only">Grant yourself cluster-admin (GKE only)</a></h3>
<p>Due to a <a href="https://cloud.google.com/container-engine/docs/role-based-access-control#defining_permissions_in_a_role">known issue</a>
in GKE, you'll need to first grant yourself <code>cluster-admin</code> privileges before
you can install the necessary RBAC manifests.</p>
<pre><code class="language-sh">kubectl create clusterrolebinding &lt;user&gt;-cluster-admin-binding --clusterrole=cluster-admin --user=&lt;user&gt;@&lt;domain&gt;
</code></pre>
<p>Replace <code>&lt;user&gt;</code> and <code>&lt;domain&gt;</code> above based on the account you use to authenticate to GKE.</p>
<h2 id="install-metacontroller-using-kustomize"><a class="header" href="#install-metacontroller-using-kustomize">Install Metacontroller using Kustomize</a></h2>
<pre><code class="language-sh"># Apply all set of production resources defined in kustomization.yaml in `production` directory .
kubectl apply -k https://github.com/metacontroller/metacontroller/manifests/production

</code></pre>
<p>If you prefer to build and host your own images, please see the
<a href="guide/../contrib/build.html">build instructions</a> in the contributor guide.</p>
<p>If your <code>kubectl</code> version does does not support <code>-k</code> flag, please
install resources mentioned in <code>manifests/production/kustomization.yaml</code>
one by one manually with <code>kubectl apply -f {{filename}}</code> command.</p>
<h2 id="install-metacontroller-using-helm"><a class="header" href="#install-metacontroller-using-helm">Install Metacontroller using Helm</a></h2>
<p>Alternatively, metacontroller can be <a href="guide/helm-install.html">installed using an Helm chart</a>.</p>
<h2 id="migrating-from-googlecloudplatformmetacontroller"><a class="header" href="#migrating-from-googlecloudplatformmetacontroller">Migrating from /GoogleCloudPlatform/metacontroller</a></h2>
<p>As current version of metacontroller uses different name of the finalizer than GCP version (GCP - <code>metacontroller.app</code>,
current version - <code>metacontroller.io</code>) thus after installing <code>metacontroller</code> you might need to clean up old finalizers,
i.e. by running:</p>
<pre><code class="language-shell">kubectl get &lt;comma separated list of your resource types here&gt; --no-headers --all-namespaces | awk '{print $2 &quot; -n &quot; $1}' | xargs -L1 -P 50 -r kubectl patch -p '{&quot;metadata&quot;:{&quot;finalizers&quot;: [null]}}' --type=merge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-metacontroller-using-helm-1"><a class="header" href="#install-metacontroller-using-helm-1">Install Metacontroller using Helm</a></h1>
<h2 id="building-the-chart-from-source-code"><a class="header" href="#building-the-chart-from-source-code">Building the chart from source code</a></h2>
<p>The chart can be built from metacontroller source:</p>
<pre><code class="language-shell">git clone https://github.com/metacontroller/metacontroller.git
cd  metacontroller
helm package deploy/helm/metacontroller --destination deploy/helm
</code></pre>
<h2 id="installing-the-chart-from-package"><a class="header" href="#installing-the-chart-from-package">Installing the chart from package</a></h2>
<pre><code class="language-shell">helm install metacontroller deploy/helm/metacontroller-helm-v*.tgz
</code></pre>
<h2 id="installing-chart-from-ghcrio"><a class="header" href="#installing-chart-from-ghcrio">Installing chart from ghcr.io</a></h2>
<p>Charts are published as <a href="https://github.com/metacontroller/metacontroller/pkgs/container/metacontroller-helm">packages on ghcr.io</a></p>
<p>You can pull them like:</p>
<ul>
<li><code>HELM_EXPERIMENTAL_OCI=1 helm pull oci://ghcr.io/metacontroller/metacontroller-helm --version=&lt;version&gt;</code></li>
</ul>
<p>as OCI is currently (at least for helm 3.8.x) a beta feature.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<table><thead><tr><th>Parameter</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>command</code></td><td>Command which is used to start metacontroller</td><td><code>/usr/bin/metacontroller</code></td></tr>
<tr><td><code>commandArgs</code></td><td>Command arguments which are used to start metacontroller. See <a href="guide/configuration.html">configuration.md</a> for additional details.</td><td><code>[ &quot;--zap-log-level=4&quot;, &quot;--discovery-interval=20s&quot;, &quot;--cache-flush-interval=30m&quot; ]</code></td></tr>
<tr><td><code>rbac.create</code></td><td>Create and use RBAC resources</td><td><code>true</code></td></tr>
<tr><td><code>image.repository</code></td><td>Image repository</td><td><code>metacontrollerio/metacontroller</code></td></tr>
<tr><td><code>image.pullPolicy</code></td><td>Image pull policy</td><td><code>IfNotPresent</code></td></tr>
<tr><td><code>image.tag</code></td><td>Image tag</td><td><code>&quot;&quot;</code> (<code>Chart.AppVersion</code>)</td></tr>
<tr><td><code>imagePullSecrets</code></td><td>Image pull secrets</td><td><code>[]</code></td></tr>
<tr><td><code>nameOverride</code></td><td>Override the deployment name</td><td><code>&quot;&quot;</code> (<code>Chart.Name</code>)</td></tr>
<tr><td><code>namespaceOverride</code></td><td>Override the deployment namespace</td><td><code>&quot;&quot;</code> (<code>Release.Namespace</code>)</td></tr>
<tr><td><code>fullnameOverride</code></td><td>Override the deployment full name</td><td><code>&quot;&quot;</code> (<code>Release.Namespace-Chart.Name</code>)</td></tr>
<tr><td><code>serviceAccount.create</code></td><td>Create service account</td><td><code>true</code></td></tr>
<tr><td><code>serviceAccount.annotations</code></td><td>ServiceAccount annotations</td><td><code>{}</code></td></tr>
<tr><td><code>serviceAccount.name</code></td><td>Service account name to use, when empty will be set to created account if <code>serviceAccount.create</code> is set else to <code>default</code></td><td><code>&quot;&quot;</code></td></tr>
<tr><td><code>podAnnotations</code></td><td>Pod annotations</td><td><code>{}</code></td></tr>
<tr><td><code>podSecurityContext</code></td><td>Pod security context</td><td><code>{}</code></td></tr>
<tr><td><code>securityContext</code></td><td>Container security context</td><td><code>{}</code></td></tr>
<tr><td><code>resources</code></td><td>CPU/Memory resource requests/limits</td><td><code>{}</code></td></tr>
<tr><td><code>nodeSelector</code></td><td>Node labels for pod assignment</td><td><code>{}</code></td></tr>
<tr><td><code>tolerations</code></td><td>Toleration labels for pod assignment</td><td><code>[]</code></td></tr>
<tr><td><code>affinity</code></td><td>Affinity settings for pod assignment</td><td><code>{}</code></td></tr>
<tr><td><code>priorityClassName</code></td><td>The name of the <code>PriorityClass</code> that will be assigned to metacontroller</td><td><code>&quot;&quot;</code></td></tr>
<tr><td><code>clusterRole.aggregationRule</code></td><td>The <code>aggregationRule</code> applied to metacontroller <code>ClusterRole</code></td><td><code>{}</code></td></tr>
<tr><td><code>clusterRole.rules</code></td><td>The <code>rules</code> applied to metacontroller <code>ClusterRole</code></td><td><code>{ &quot;apiGroups&quot;: &quot;*&quot;, &quot;resources&quot;: &quot;*&quot;, &quot;verbs&quot;: &quot;*&quot; }</code></td></tr>
<tr><td><code>replicas</code></td><td>Specifies the number of metacontroller pods that will be deployed</td><td><code>1</code></td></tr>
<tr><td><code>podDisruptionBudget</code></td><td>The <code>podDisruptionBudget</code> applied to metacontroller <code>pods</code></td><td><code>{}</code></td></tr>
<tr><td><code>service.enabled</code></td><td>If <code>true</code>, then create a <code>Service</code> to expose ports</td><td><code>false</code></td></tr>
<tr><td><code>service.ports</code></td><td>List of ports that are exposed on the <code>Service</code></td><td><code>[]</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h1>
<p>This page describes how to configure Metacontroller.</p>
<ul>
<li><a href="guide/configuration.html#command-line-flags">Command line flags</a></li>
<li><a href="guide/configuration.html#running-multiple-instances">Running multiple instances</a>
<ul>
<li><a href="guide/configuration.html#pros">Pros</a></li>
<li><a href="guide/configuration.html#cons">Cons</a></li>
<li><a href="guide/configuration.html#example">Example</a>
<ul>
<li><a href="guide/configuration.html#1-configure-metacontroller">1. Configure Metacontroller</a></li>
<li><a href="guide/configuration.html#2-specify-labels-on-the-controller">2. Specify labels on the Controller</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="command-line-flags"><a class="header" href="#command-line-flags">Command line flags</a></h2>
<p>The Metacontroller server has a few settings that can be configured
with command-line flags (by editing the Metacontroller StatefulSet
in <code>manifests/metacontroller.yaml</code>):</p>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--zap-log-level</code></td><td>Zap log level to configure the verbosity of logging. Can be one of ‘debug’, ‘info’, ‘error’, or any integer value &gt; 0 which corresponds to custom debug levels of increasing verbosity(e.g. <code>--zap-log-level=5</code>). Level 4 logs Metacontroller's interaction with the API server. Levels 5 and up additionally log details of Metacontroller's invocation of lambda hooks. See the <a href="guide/./troubleshooting.html">troubleshooting guide</a> for more.</td></tr>
<tr><td><code>--zap-devel</code></td><td>Development Mode (e.g. <code>--zap-devel</code>) defaults(encoder=consoleEncoder,logLevel=Debug,stackTraceLevel=Warn).</td></tr>
<tr><td><code>--zap-encoder</code></td><td>Zap log encoding - <code>json</code> or <code>console</code> (e.g. <code>--zap-encoder='json'</code>) defaults(encoder=consoleEncoder,logLevel=Debug,stackTraceLevel=Warn).</td></tr>
<tr><td><code>--zap-stacktrace-level</code></td><td>Zap Level at and above which stacktraces are captured - one of <code>info</code> or <code>error</code> (e.g. <code>--zap-stacktrace-level='info'</code>).</td></tr>
<tr><td><code>--discovery-interval</code></td><td>How often to refresh discovery cache to pick up newly-installed resources (e.g. <code>--discovery-interval=10s</code>).</td></tr>
<tr><td><code>--cache-flush-interval</code></td><td>How often to flush local caches and relist objects from the API server (e.g. <code>--cache-flush-interval=30m</code>).</td></tr>
<tr><td><code>--metrics-address</code></td><td>The address to bind metrics endpoint - /metrics (e.g. <code>--metrics-address=:9999</code>). It can be set to &quot;0&quot; to disable the metrics serving.</td></tr>
<tr><td><code>--kubeconfig</code></td><td>Path to kubeconfig file (same format as used by kubectl); if not specified, use in-cluster config (e.g. <code>--kubeconfig=/path/to/kubeconfig</code>).</td></tr>
<tr><td><code>--client-go-qps</code></td><td>Number of queries per second client-go is allowed to make (default 5, e.g. <code>--client-go-qps=100</code>)</td></tr>
<tr><td><code>--client-go-burst</code></td><td>Allowed burst queries for client-go (default 10, e.g. <code>--client-go-burst=200</code>)</td></tr>
<tr><td><code>--workers</code></td><td>Number of sync workers to run (default 5, e.g. <code>--workers=100</code>)</td></tr>
<tr><td><code>--events-qps</code></td><td>Rate of events flowing per object (default - 1 event per 5 minutes, e.g. <code>--events-qps=0.0033</code>)</td></tr>
<tr><td><code>--events-burst</code></td><td>Number of events allowed to send per object (default 25, e.g. <code>--events-burst=25</code>)</td></tr>
<tr><td><code>--pprof-address</code></td><td>Enable pprof and bind to endpoint /debug/pprof, set to 0 to disable pprof serving (default 0, e.g. <code>--pprof-address=:6060</code>)</td></tr>
<tr><td><code>--leader-election</code></td><td>Determines whether or not to use leader election when starting metacontroller (default <code>false</code>, e.g., <code>--leader-election</code>)</td></tr>
<tr><td><code>--leader-election-resource-lock</code></td><td>Determines which resource lock to use for leader election (default <code>leases</code>, e.g., <code>--leader-election-resource-lock=leases</code>). Valid resource locks are <code>endpoints</code>, <code>configmaps</code>, <code>leases</code>, <code>endpointsleases</code>, or <code>configmapsleases</code>. See the client-go documentation <a href="https://pkg.go.dev/k8s.io/client-go/tools/leaderelection/resourcelock#pkg-constants">leaderelection/resourcelock</a> for additional information.</td></tr>
<tr><td><code>--leader-election-namespace</code></td><td>Determines the namespace in which the leader election resource will be created. If metacontroller is running in-cluster, the default leader election namespace is the same namespace as metacontroller. If metacontroller is running out-of-cluster, the default leader election namespace is undefined. If you are running metacontroller out-of-cluster with leader election enabled, you must specify the leader election namespace. (e.g., <code>--leader-election-namespace=metacontroller</code>)</td></tr>
<tr><td><code>--leader-election-id</code></td><td>Determines the name of the resource that leader election will use for holding the leader lock. For example, if the leader election id is <code>metacontroller</code> and the leader election resource lock is <code>leases</code>, then a resource of kind <code>leases</code> with metadata.name <code>metacontroller</code> will hold the leader lock. (default metacontroller, e.g., <code>--leader-election-id=metacontroller</code>)</td></tr>
<tr><td><code>--health-probe-bind-address</code></td><td>The address the health probes endpoint binds to (default &quot;:8081&quot;, e.g., <code>--health-probe-bind-address=&quot;:8081&quot;</code>)</td></tr>
<tr><td><code>--target-label-selector</code></td><td><a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors">Label selector</a> used to restrict an instance of metacontroller to manage specific Composite and Decorator controllers, which enables the ability to run multiple metacontroller instances on the same cluster (e.g. <code>--target-label-selector=controller-group=cicd&quot;</code>)</td></tr>
<tr><td><code>--aply-strategy</code></td><td>Strategy to use for applying changes to objects (default <code>dynamic-apply</code>, e.g., <code>--apply-strategy=dynamic-apply</code>). Valid strategies are <code>server-side-apply</code>, <code>dynamic-apply</code></td></tr>
<tr><td><code>--apply-strategy-ssa-field-manager</code></td><td>FieldManager to use for server-side apply (default <code>metacontroller</code>, e.g., <code>--apply-strategy-ssa-field-manager=metacontroller</code>)</td></tr>
</tbody></table>
<p>Logging flags are being set by <code>controller-runtime</code>, more on the meaning of them can be found <a href="https://sdk.operatorframework.io/docs/building-operators/golang/references/logging/#overview">here</a></p>
<h2 id="running-multiple-instances"><a class="header" href="#running-multiple-instances">Running multiple instances</a></h2>
<p>Metacontroller can be setup to run multiple instances in the same Kubernetes cluster that can watch resources based on separate grouping or as a way to split responsibilities; which can also act as a scaling aid.</p>
<p>This is made possible by configuring Metacontroller with the <code>target-label-selector</code> argument.</p>
<p>Further details on this feature can be found <a href="https://github.com/metacontroller/metacontroller/issues/218">here</a>.</p>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<ul>
<li>Clean separation of different Metacontroller instances, in case of
<ul>
<li>Permissions needed to manage its controllers (they can be limited to what the actual operator needs)</li>
<li>Allowing the Sidecar pattern - so in the pod there is Metacontroller pod and operator pod, metacontroller manages only this operator.</li>
</ul>
</li>
<li>Allow scaling (in a primitive way in term of separation of concerns / grouping)</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<ul>
<li>Metacontroller fighting over resources - can be caused by two Metacontroller instances managing the same CRD
<ul>
<li>Care needs to be taken when configuring multiple Metacontroller instances and not just deploy the default configuration but properly set the <code>target-label-selector</code> value for each Metacontroller instance to be unique if what it is managing.</li>
</ul>
</li>
</ul>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<h4 id="1-configure-metacontroller"><a class="header" href="#1-configure-metacontroller">1. Configure Metacontroller</a></h4>
<p>Add the <code>--target-label-selector</code> argument to Metacontroller binary arguments; below this is inside the Kubernetes deployment spec for Metacontroller:</p>
<pre><code class="language-yaml">
---
spec:
  containers:
    - args:
        - --zap-devel
        - --zap-log-level=5
        - --discovery-interval=5s
        - --target-label-selector=controller-group=cicd
</code></pre>
<p>You can also use the more advanced features like <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#equality-based-requirement">Equality-based requirement</a> and <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#set-based-requirement">Set-base requirement</a> when defining your target label selector.</p>
<h4 id="2-specify-labels-on-the-controller"><a class="header" href="#2-specify-labels-on-the-controller">2. Specify labels on the Controller</a></h4>
<p>Below is an example of a <a href="https://metacontroller.github.io/metacontroller/api/decoratorcontroller.html">Decorator Controller</a> that has the appropriate label added so that this instance of Metacontroller can target and manage it:</p>
<pre><code class="language-yaml">apiVersion: metacontroller.k8s.io/v1alpha1
kind: DecoratorController
metadata:
  name: pod-name-label
  labels:
    controller-group: cicd
spec:
  resources:
    - apiVersion: v1
      resource: pods
      annotationSelector:
        matchExpressions:
          - { key: pod-name-label, operator: Exists }
  hooks:
    sync:
      webhook:
        url: http://service-per-pod.metacontroller/sync-pod-name-label
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-controller-1"><a class="header" href="#create-a-controller-1">Create a Controller</a></h1>
<p>This tutorial walks through a simple example of creating a controller in Python
with Metacontroller.</p>
<ul>
<li><a href="guide/create.html#prerequisites">Prerequisites</a></li>
<li><a href="guide/create.html#hello-world">Hello, World!</a>
<ul>
<li><a href="guide/create.html#define-a-custom-resource">Define a custom resource</a></li>
<li><a href="guide/create.html#define-a-custom-controller">Define a custom controller</a></li>
<li><a href="guide/create.html#write-a-webhook">Write a webhook</a></li>
<li><a href="guide/create.html#deploy-the-webhook">Deploy the webhook</a></li>
<li><a href="guide/create.html#try-it-out">Try it out</a></li>
<li><a href="guide/create.html#clean-up">Clean up</a></li>
</ul>
</li>
<li><a href="guide/create.html#next-steps">Next Steps</a></li>
</ul>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<ul>
<li>Kubernetes v1.9+</li>
<li>You should have <code>kubectl</code> available and configured to talk to the desired cluster.</li>
<li>You should have already <a href="guide/./install.html">installed Metacontroller</a>.</li>
</ul>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<p>In this example, we'll create a useless controller that runs a single Pod
that prints a greeting to its standard output.
Once you're familiar with the general process, you can look through the
<a href="guide/../examples.html">examples</a> page to find concepts that actually do something useful.</p>
<p>To make cleanup easier, first create a new Namespace called <code>hello</code>:</p>
<pre><code class="language-sh">kubectl create namespace hello
</code></pre>
<p>We'll put all our Namespace-scoped objects there by adding <code>-n hello</code> to the
<code>kubectl</code> commands.</p>
<h3 id="define-a-custom-resource"><a class="header" href="#define-a-custom-resource">Define a custom resource</a></h3>
<p>Our example controller will implement the behavior for a new API represented
as a <a href="guide/../concepts.html#custom-resource">custom resource</a>.</p>
<p>First, let's use the built-in <a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/#customresourcedefinitions">CustomResourceDefinition</a> API to set up a storage location
(a <em>helloworlds</em> <a href="guide/../concepts.html#resource">resource</a>) for objects of our custom type (HelloWorld).</p>
<p>Save the following to a file called <code>crd.yaml</code>:</p>
<pre><code class="language-yaml">apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: helloworlds.example.com
spec:
  group: example.com
  names:
    kind: HelloWorld
    plural: helloworlds
    singular: helloworld
  scope: Namespaced
  versions:
  - name: v1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        type: object
        properties:
          spec:
            type: object
            properties:
              who:
                type: string
    subresources:
     status: {}
</code></pre>
<p>Then apply it to your cluster:</p>
<pre><code class="language-sh">kubectl apply -f crd.yaml
</code></pre>
<h3 id="define-a-custom-controller"><a class="header" href="#define-a-custom-controller">Define a custom controller</a></h3>
<p>For each HelloWorld object, we're going to create a Pod as a child object,
so we'll use the <a href="guide/../api/compositecontroller.html">CompositeController</a> API to implement a controller that
defines this parent-child relationship.</p>
<p>Save the following to a file called <code>controller.yaml</code>:</p>
<pre><code class="language-yaml">apiVersion: metacontroller.k8s.io/v1alpha1
kind: CompositeController
metadata:
  name: hello-controller
spec:
  generateSelector: true
  parentResource:
    apiVersion: example.com/v1
    resource: helloworlds
  childResources:
  - apiVersion: v1
    resource: pods
    updateStrategy:
      method: Recreate
  hooks:
    sync:
      webhook:
        url: http://hello-controller.hello/sync
</code></pre>
<p>Then apply it to your cluster:</p>
<pre><code class="language-sh">kubectl apply -f controller.yaml
</code></pre>
<p>This tells Metacontroller to start a <a href="guide/../concepts.html#controller">reconciling control loop</a>
for you, running inside the Metacontroller server.
The parameters under <code>spec:</code> let you tune the behavior of the controller
<a href="guide/../features.html#declarative-reconciliation">declaratively</a>.</p>
<p>In this case:</p>
<ul>
<li>We set <a href="guide/../api/compositecontroller.html#generate-selector"><code>generateSelector</code></a> to <code>true</code> to mimic the built-in
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector">Job</a> API since we're running a Pod to completion and don't want
to share Pods across invocations.</li>
<li>The <a href="guide/../api/compositecontroller.html#parent-resource"><code>parentResource</code></a> is our custom resource called <code>helloworlds</code>.</li>
<li>The idea of CompositeController is that the parent resource represents
objects that are composed of other objects.
A HelloWorld is composed of just a Pod, so we have only one entry in the
<a href="guide/../api/compositecontroller.html#child-resources"><code>childResources</code></a> list.</li>
<li>For each child resource, we can optionally set an
<a href="guide/../api/compositecontroller.html#child-update-strategy"><code>updateStrategy</code></a> to specify what to do if a child object
needs to be updated.
Since Pods are effectively immutable, we use the <code>Recreate</code> method,
which means, &quot;delete the outdated object and create a new one&quot;.</li>
<li>Finally, we tell Metacontroller how to invoke the <code>sync</code> webhook,
which is where we'll define the business logic of our controller.
The example relies on in-cluster DNS to resolve the address of the
<code>hello-controller</code> Service (which we'll define below)
within the <code>hello</code> Namespace.</li>
</ul>
<h3 id="write-a-webhook"><a class="header" href="#write-a-webhook">Write a webhook</a></h3>
<p>Metacontroller will handle the <a href="guide/../features.html#controller-best-practices">controllery bits</a>
for us, but we still need to tell it what our controller actually does.</p>
<p>To define our business logic, we write a webhook that generates child objects
based on the parent spec, which is provided as JSON in the webhook request.
The <a href="guide/../api/compositecontroller.html#sync-hook-request">sync hook request</a> contains additional information as well,
but the parent spec is all we need for this example.</p>
<p>You can write Metacontroller hooks in any language, but Python is particularly
nice because its <em>dictionary</em> type is convenient for programmatically building
JSON objects (like the Pod object below).</p>
<p>If you have a preferred Functions-as-a-Service framework, you can use that to
write your webhook, but we'll keep this example self-contained by relying on
the basic HTTP server module in the Python standard library.
The <code>do_POST()</code> method handles decoding and encoding the request and response
as JSON.</p>
<p>The real hook logic is in the <code>sync()</code> method, and consists primarily of
building a Pod object.
Because Metacontroller uses <a href="guide/../api/apply.html">apply semantics</a>, you can simply return the
Pod object as if you were creating it, every time.
If the Pod already exists, Metacontroller will take care of updates according
to your <a href="guide/../api/compositecontroller.html#child-update-strategy">update strategy</a>.</p>
<p>In this case, we set the update method to <code>Recreate</code>, so an existing Pod
would be deleted and replaced if it doesn't match the desired state returned
by your hook.
Notice, however, that the hook code below doesn't need to mention any of that
because it's only responsible for computing the desired state;
the Metacontroller server takes care of
<a href="guide/../features.html#declarative-reconciliation">reconciling with the observed state</a>.</p>
<p>Save the following to a file called <code>sync.py</code>:</p>
<pre><code class="language-python">from http.server import BaseHTTPRequestHandler, HTTPServer
import json

class Controller(BaseHTTPRequestHandler):
  def sync(self, parent, children):
    # Compute status based on observed state.
    desired_status = {
      &quot;pods&quot;: len(children[&quot;Pod.v1&quot;])
    }

    # Generate the desired child object(s).
    who = parent.get(&quot;spec&quot;, {}).get(&quot;who&quot;, &quot;World&quot;)
    desired_pods = [
      {
        &quot;apiVersion&quot;: &quot;v1&quot;,
        &quot;kind&quot;: &quot;Pod&quot;,
        &quot;metadata&quot;: {
          &quot;name&quot;: parent[&quot;metadata&quot;][&quot;name&quot;]
        },
        &quot;spec&quot;: {
          &quot;restartPolicy&quot;: &quot;OnFailure&quot;,
          &quot;containers&quot;: [
            {
              &quot;name&quot;: &quot;hello&quot;,
              &quot;image&quot;: &quot;busybox&quot;,
              &quot;command&quot;: [&quot;echo&quot;, &quot;Hello, %s!&quot; % who]
            }
          ]
        }
      }
    ]

    return {&quot;status&quot;: desired_status, &quot;children&quot;: desired_pods}

  def do_POST(self):
    # Serve the sync() function as a JSON webhook.
    observed = json.loads(self.rfile.read(int(self.headers.get(&quot;content-length&quot;))))
    desired = self.sync(observed[&quot;parent&quot;], observed[&quot;children&quot;])

    self.send_response(200)
    self.send_header(&quot;Content-type&quot;, &quot;application/json&quot;)
    self.end_headers()
    self.wfile.write(json.dumps(desired).encode())

HTTPServer((&quot;&quot;, 80), Controller).serve_forever()
</code></pre>
<p>Then load it into your cluster as a ConfigMap:</p>
<pre><code class="language-sh">kubectl -n hello create configmap hello-controller --from-file=sync.py
</code></pre>
<p><em>Note</em>: The <code>-n hello</code> flag is important to put the ConfigMap in the
<code>hello</code> namespace we created for the tutorial.</p>
<h3 id="deploy-the-webhook"><a class="header" href="#deploy-the-webhook">Deploy the webhook</a></h3>
<p>Finally, since we wrote our hook as a self-contained Python web server,
we need to deploy it somewhere that Metacontroller can reach.
Luckily, we have this thing called Kubernetes which is great at hosting
stateless web services.</p>
<p>Since our hook consists of only a small Python script, we'll use a generic
Python container image and mount the script from the ConfigMap we created.</p>
<p>Save the following to a file called <code>webhook.yaml</code>:</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: hello-controller
  template:
    metadata:
      labels:
        app: hello-controller
    spec:
      containers:
      - name: controller
        image: python:3
        command: [&quot;python3&quot;, &quot;/hooks/sync.py&quot;]
        volumeMounts:
        - name: hooks
          mountPath: /hooks
      volumes:
      - name: hooks
        configMap:
          name: hello-controller
---
apiVersion: v1
kind: Service
metadata:
  name: hello-controller
spec:
  selector:
    app: hello-controller
  ports:
  - port: 80
</code></pre>
<p>Then apply it to your cluster:</p>
<pre><code class="language-sh">kubectl -n hello apply -f webhook.yaml
</code></pre>
<h3 id="try-it-out"><a class="header" href="#try-it-out">Try it out</a></h3>
<p>Now we can create HelloWorld objects and see what they do.</p>
<p>Save the following to a file called <code>hello.yaml</code>:</p>
<pre><code class="language-yaml">apiVersion: example.com/v1
kind: HelloWorld
metadata:
  name: your-name
spec:
  who: Your Name
</code></pre>
<p>Then apply it to your cluster:</p>
<pre><code class="language-sh">kubectl -n hello apply -f hello.yaml
</code></pre>
<p>Our controller should see this and create a Pod that prints a greeting
and then exits.</p>
<pre><code class="language-sh">kubectl -n hello get pods
</code></pre>
<p>You should see something like this:</p>
<pre><code class="language-console">NAME                                READY     STATUS      RESTARTS   AGE
hello-controller-746fc7c4dc-rzslh   1/1       Running     0          2m
your-name                           0/1       Completed   0          15s
</code></pre>
<p>Then you can check the logs on the <em>Completed</em> Pod:</p>
<pre><code class="language-sh">kubectl -n hello logs your-name
</code></pre>
<p>Which should look like this:</p>
<pre><code class="language-console">Hello, Your Name!
</code></pre>
<p>Now let's look at what happens when you update the parent object,
for example to change the name:</p>
<pre><code class="language-sh">kubectl -n hello patch helloworld your-name --type=merge -p '{&quot;spec&quot;:{&quot;who&quot;:&quot;My Name&quot;}}'
</code></pre>
<p>If you now check the Pod logs again:</p>
<pre><code class="language-sh">kubectl -n hello logs your-name
</code></pre>
<p>You should see that the Pod was updated (actually deleted and recreated)
to print a greeting to the new name, even though the hook code doesn't
mention anything about updates.</p>
<pre><code class="language-console">Hello, My Name!
</code></pre>
<h3 id="clean-up"><a class="header" href="#clean-up">Clean up</a></h3>
<p>Another thing Metacontroller does for you by default is set up links
so that child objects are removed by the garbage collector when the parent
goes away (assuming your cluster is version 1.8+).</p>
<p>You can check this by deleting the parent:</p>
<pre><code class="language-sh">kubectl -n hello delete helloworld your-name
</code></pre>
<p>And then checking for the child Pod:</p>
<pre><code class="language-sh">kubectl -n hello get pods
</code></pre>
<p>You should see that the child Pod was cleaned up automatically,
so only the webhook Pod remains:</p>
<pre><code class="language-console">NAME                                READY     STATUS      RESTARTS   AGE
hello-controller-746fc7c4dc-rzslh   1/1       Running     0          3m
</code></pre>
<p>When you're done with the tutorial, you should remove the controller,
CRD, and Namespace as follows:</p>
<pre><code class="language-sh">kubectl delete compositecontroller hello-controller
kubectl delete crd helloworlds.example.com
kubectl delete ns hello
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li>Explore other <a href="guide/../examples.html">example controllers</a>.</li>
<li>Read about <a href="guide/./best-practices.html">best practices</a> for writing controllers.</li>
<li>Learn how to <a href="guide/./troubleshooting.html">troubleshoot controllers</a>.</li>
<li>Dive into the details of all the <a href="guide/../api.html">available Metacontroller APIs</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constraints-and-best-practices"><a class="header" href="#constraints-and-best-practices">Constraints and best practices</a></h1>
<p>This is a collection of recommendations for writing controllers with Metacontroller.</p>
<p>If you have something to add to the collection, please send a pull request against
<a href="https://www.github.com/metacontroller/metacontroller/tree/master/docs/src/guide/best-practices.md">this document</a>.</p>
<ul>
<li><a href="guide/best-practices.html#constraints">Constraints</a>
<ul>
<li><a href="guide/best-practices.html#objects-relationship">Objects relationship</a></li>
</ul>
</li>
<li><a href="guide/best-practices.html#lambda-hooks">Lambda Hooks</a>
<ul>
<li><a href="guide/best-practices.html#apply-semantics">Apply Semantics</a></li>
<li><a href="guide/best-practices.html#side-effects">Side Effects</a></li>
<li><a href="guide/best-practices.html#status">Status</a>
<ul>
<li><a href="guide/best-practices.html#working-with-status-subresource-in-metacontroller">Working with Status subresource in metacontroller</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<h3 id="objects-relationship"><a class="header" href="#objects-relationship">Objects relationship</a></h3>
<p>Because of limitations of Kubernetes <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/garbage-collection.md#api-changes">garbage collection</a>
we have following restrictions between objects:</p>
<table><thead><tr><th>Parent</th><th>Child</th><th>Related</th></tr></thead><tbody>
<tr><td>Cluster</td><td>- Cluster <br> - Namespaced (any namespace)</td><td>- Cluster <br> - Namespaced (any namespace)</td></tr>
<tr><td>Namespaced</td><td>- Namespaced (the same namespace as parent)</td><td>-  Namespaced (the same namespace as parent)</td></tr>
</tbody></table>
<h2 id="lambda-hooks"><a class="header" href="#lambda-hooks">Lambda Hooks</a></h2>
<h3 id="apply-semantics"><a class="header" href="#apply-semantics">Apply Semantics</a></h3>
<p>Because Metacontroller uses <a href="guide/../api/apply.html">apply semantics</a>, you don't have to
think about whether a given object needs to be created (because it doesn't exist)
or patched (because it exists and some fields don't match your desired state).
In either case, you should generate a fresh object from scratch with only the
fields you care about filled in.</p>
<p>For example, suppose you create an object like this:</p>
<pre><code class="language-yaml">apiVersion: example.com/v1
kind: Foo
metadata:
  name: my-foo
spec:
  importantField: 1
</code></pre>
<p>Then later you decide to change the value of <code>importantField</code> to 2.</p>
<p>Since Kubernetes API objects can be edited by the API server, users, and other
controllers to collaboratively produce emergent behavior, the object you observe
might now look like this:</p>
<pre><code class="language-yaml">apiVersion: example.com/v1
kind: Foo
metadata:
  name: my-foo
  stuffFilledByAPIServer: blah
spec:
  importantField: 1
  otherField: 5
</code></pre>
<p>To avoid overwriting the parts of the object you don't care about, you would
ordinarily need to either build a patch or use a retry loop to send
concurrency-safe updates.
With apply semantics, you instead just call your &quot;generate object&quot; function
again with the new values you want, and return this (as JSON):</p>
<pre><code class="language-yaml">apiVersion: example.com/v1
kind: Foo
metadata:
  name: my-foo
spec:
  importantField: 2
</code></pre>
<p>Metacontroller will take care of merging your change to <code>importantField</code> while
preserving the fields you don't care about that were set by others.</p>
<h3 id="side-effects"><a class="header" href="#side-effects">Side Effects</a></h3>
<p>Your hook code should generally be free of side effects whenever possible.
Ideally, you should interpret a call to your hook as asking,
&quot;Hypothetically, if the observed state of the world were like this, what would
your desired state be?&quot;</p>
<p>In particular, Metacontroller may ask you about such hypothetical scenarios
during rolling updates, when your object is undergoing a slow transition between
two desired states.
If your hook has to produce side effects to work, you should avoid enabling
rolling updates on that controller.</p>
<h3 id="status"><a class="header" href="#status">Status</a></h3>
<p>If your object uses the Spec/Status convention, keep in mind that the Status
returned from your hook should ideally reflect a judgement on only the observed
objects that were sent to you.
The Status you compute should not yet account for your desired state, because
the actual state of the world may not match what you want yet.</p>
<p>For example, if you observe 2 Pods, but you return a desired list of 3 Pods,
you should return a Status that reflects only the observed Pods
(e.g. <code>replicas: 2</code>).
This is important so that Status reflects present reality, not future desires.</p>
<h4 id="working-with-status-subresource-in-metacontroller"><a class="header" href="#working-with-status-subresource-in-metacontroller">Working with Status subresource in metacontroller</a></h4>
<p>If you would like to expose and use the <code>Status</code> subresource in your custom resource, you should take care of:</p>
<ol>
<li>having a proper CRD schema definition for <code>Status</code> section in order to let metacontroller
update it successfully - it must be a part of CRD schema, i.e.</li>
</ol>
<pre><code class="language-yaml">---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: configmappropagations.examples.metacontroller.io
spec:
  ...
  versions:
  - name: v1alpha1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        type: object
        properties:
          spec:
            ...
          status:
            type: object
            properties:
              expected_copies:
                type: integer
              actual_copies:
                type: integer
              observedGeneration:
                type: integer
        required:
        - spec
    subresources:
      status: {}
</code></pre>
<ol start="2">
<li>your controller must be strict about the types in the schema defined in CRD, i.e., in example above
do not try to set any of the <code>integer</code> fields as <code>string</code>s, or add additional fields there.</li>
</ol>
<p>To read more about <code>Status</code> subresource please look at:</p>
<ul>
<li>Kubernetes documentation - https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h1>
<p>This is a collection of tips for debugging controllers written with Metacontroller.</p>
<p>If you have something to add to the collection, please send a pull request against
<a href="https://github.com/metacontroller/metacontroller/tree/master/docs/src/guide/troubleshooting.md">this document</a>.</p>
<ul>
<li><a href="guide/troubleshooting.html#events">Events</a></li>
<li><a href="guide/troubleshooting.html#metacontroller-logs">Metacontroller Logs</a>
<ul>
<li><a href="guide/troubleshooting.html#log-levels">Log Levels</a></li>
<li><a href="guide/troubleshooting.html#common-log-messages">Common Log Messages</a></li>
</ul>
</li>
<li><a href="guide/troubleshooting.html#webhook-logs">Webhook Logs</a></li>
</ul>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>As metacontroller emits kubernetes Events for internal actions, you might check events on parent object, like:</p>
<pre><code class="language-shell">kubectl describe secretpropagations.examples.metacontroller.io &lt;name&gt;
</code></pre>
<p>where, at the end, you will see all events related with given parent:</p>
<pre><code class="language-yaml">Name:         secret-propagation
Namespace:    
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  examples.metacontroller.io/v1alpha1
Kind:         SecretPropagation
Metadata:
  Creation Timestamp:  2021-07-14T20:25:09Z
...
Spec:
  Source Name:       shareable
  Source Namespace:  omega
  Target Namespace Label Selector:
    Match Labels:
      Propagate:  true
Status:
  Working:  fine
Events:
  Type     Reason     Age               From            Message
  ----     ------     ----              ----            -------
  Warning  SyncError  1s (x11 over 8s)  metacontroller  Sync error: sync hook failed for SecretPropagation /secret-propagation: sync hook failed: http error: Post &quot;http://secret-propagation-controller.metacontroller/sync&quot;: dial tcp 10.96.138.14:80: connect: connection refused

</code></pre>
<p>You can access also events using <code>kubectl get events</code>, which return all events from given namespace. As metacontroller
CRD's are might be cluster wide, they can land in <code>default</code> namespace:</p>
<pre><code class="language-shell">&gt; kubectl get events -n default  
39m         Normal    Started                 compositecontroller/secret-propagation-controller      Started controller: secret-propagation-controller
39m         Normal    Starting                compositecontroller/secret-propagation-controller      Starting controller: secret-propagation-controller
39m         Normal    Stopping                compositecontroller/secret-propagation-controller      Stopping controller: secret-propagation-controller
39m         Normal    Stopped                 compositecontroller/secret-propagation-controller      Stopped controller: secret-propagation-controller
6m25s       Normal    Started                 compositecontroller/secret-propagation-controller      Started controller: secret-propagation-controller
6m25s       Normal    Starting                compositecontroller/secret-propagation-controller      Starting controller: secret-propagation-controller
2m27s       Normal    Stopping                compositecontroller/secret-propagation-controller      Stopping controller: secret-propagation-controller
2m27s       Normal    Stopped                 compositecontroller/secret-propagation-controller      Stopped controller: secret-propagation-controller

</code></pre>
<h2 id="metacontroller-logs"><a class="header" href="#metacontroller-logs">Metacontroller Logs</a></h2>
<p>Until Metacontroller <a href="https://www.github.com/GoogleCloudPlatform/metacontroller/issues/7">emits events</a>,
the first place to look when troubleshooting controller behavior is the logs for
the Metacontroller server itself.</p>
<p>For example, you can fetch the last 25 lines with a command like this:</p>
<pre><code class="language-shell">kubectl -n metacontroller logs --tail=25 -l app=metacontroller
</code></pre>
<h3 id="log-levels"><a class="header" href="#log-levels">Log Levels</a></h3>
<p>You can customize the verbosity of the Metacontroller server's logs with the
<code>--zap-log-level</code> flag.</p>
<p>At all log levels, Metacontroller will log the progress of server startup and
shutdown, as well as major changes like starting and stopping hosted controllers.</p>
<p>At level 4 and above, Metacontroller will log actions (like create/update/delete)
on individual objects (like Pods) that it takes on behalf of hosted controllers.
It will also log when it decides to sync a given controller as well as events
that may trigger a sync.</p>
<p>At level 5 and above, Metacontroller will log the diffs between existing objects,
and the desired state of those objects returned by controller hooks.</p>
<p>At level 6 and above, Metacontroller will log every hook invocation as well as
the JSON request and response bodies.</p>
<h3 id="common-log-messages"><a class="header" href="#common-log-messages">Common Log Messages</a></h3>
<p>Since API discovery info is refreshed periodically, you may see log messages
like this when you start a controller that depends on a recently-installed CRD:</p>
<pre><code class="language-plaintext">failed to sync CompositeController &quot;my-controller&quot;: discovery: can't find resource &lt;resource&gt; in apiVersion &lt;group&gt;/&lt;version&gt;
</code></pre>
<p>Usually, this should fix itself within about 30s when the new CRD is discovered.
If this message continues indefinitely, check that the resource name and API
group/version are correct.</p>
<p>You may also notice periodic log messages like this:</p>
<pre><code class="language-plaintext">Watch close - *unstructured.Unstructured total &lt;X&gt; items received
</code></pre>
<p>This comes from the underlying client-go library, and just indicates when the
shared caches are periodically flushed to place an upper bound on cache
inconsistency due to potential silent failures in long-running watches.</p>
<h2 id="webhook-logs"><a class="header" href="#webhook-logs">Webhook Logs</a></h2>
<p>If you return an HTTP error code (e.g., 500) from your webhook,
the Metacontroller server will log the text of the response body.</p>
<p>If you need more detail on what's happening inside your hook code, as opposed to
what Metacontroller does for you, you'll need to add log statements to your own
code and inspect the logs on your webhook server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API reference</a></h1>
<p>This section contains detailed reference information for the APIs offered by Metacontroller.</p>
<p>See the <a href="./guide.html">user guide</a> for introductions and step-by-step walkthroughs.</p>
<h2 id="apply-semantics-1"><a class="header" href="#apply-semantics-1"><a href="./api/apply.html">Apply Semantics</a></a></h2>
<p>This page describes how Metacontroller emulates kubectl apply.</p>
<h2 id="compositecontroller-1"><a class="header" href="#compositecontroller-1"><a href="./api/compositecontroller.html">CompositeController</a></a></h2>
<p>CompositeController is an API provided by Metacontroller, designed to facilitate custom controllers whose primary purpose is to manage a set of child objects...</p>
<h2 id="controllerrevision"><a class="header" href="#controllerrevision"><a href="./api/controllerrevision.html">ControllerRevision</a></a></h2>
<p>ControllerRevision is an internal API used by Metacontroller to implement declarative rolling updates.</p>
<h2 id="decoratorcontroller-1"><a class="header" href="#decoratorcontroller-1"><a href="./api/decoratorcontroller.html">DecoratorController</a></a></h2>
<p>DecoratorController is an API provided by Metacontroller, designed to facilitate adding new behavior to existing resources. You can define rules for which re...</p>
<h2 id="hook"><a class="header" href="#hook"><a href="./api/hook.html">Hook</a></a></h2>
<p>This page describes how hook targets are defined in various APIs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apply-semantics-2"><a class="header" href="#apply-semantics-2">Apply Semantics</a></h1>
<p>This page describes how Metacontroller applies changes to managed resources. Historically, Metacontroller has used a dynamic apply approach, which emulates <a href="https://kubernetes.io/docs/reference/kubectl/generated/kubectl_apply/"><code>kubectl apply</code></a>, particularly for working with CRDs.</p>
<p>Now, Metacontroller also supports Kubernetes server-side apply (SSA), which is the recommended approach for declarative resource management in Kubernetes. SSA enables better field ownership tracking and is the future of Kubernetes resource application.</p>
<p>Below, we explain the motivation behind Metacontroller's apply mechanisms and describe both dynamic apply and server-side apply, including their use cases and trade-offs.</p>
<ul>
<li><a href="api/apply.html#motivation">Motivation</a></li>
<li><a href="api/apply.html#dynamic-apply">Dynamic Apply</a>
<ul>
<li><a href="api/apply.html#conventions">Conventions</a></li>
<li><a href="api/apply.html#limitations">Limitations</a></li>
</ul>
</li>
<li><a href="api/apply.html#server-side-apply">Server-Side Apply</a>
<ul>
<li><a href="api/apply.html#how-metacontroller-uses-server-side-apply">How Metacontroller Uses Server-Side Apply</a></li>
<li><a href="api/apply.html#example-of-server-side-apply">Example of Server-Side Apply</a></li>
<li><a href="api/apply.html#comparison-dynamic-apply-vs-server-side-apply">Comparison: Dynamic Apply vs. Server-Side Apply</a></li>
<li><a href="api/apply.html#enabling-server-side-apply">Enabling Server-Side Apply</a></li>
</ul>
</li>
<li><a href="api/apply.html#future-direction">Future Direction</a></li>
</ul>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>This section explains why Metacontroller uses <code>apply</code> semantics.</p>
<p>As an example, suppose you create a simple Pod like this
with <code>kubectl apply -f</code>:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-app
spec:
  containers:
    - name: nginx
      image: nginx
</code></pre>
<p>If you then read back the Pod you created with <code>kubectl get pod my-pod -o yaml</code>,
you'll see a lot of extra fields filled in that you never set:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  annotations:
    kubernetes.io/limit-ranger: 'LimitRanger plugin set: cpu request for container
      nginx'
  creationTimestamp: 2018-04-13T00:46:51Z
  labels:
    app: my-app
  name: my-pod
  namespace: default
  resourceVersion: &quot;28573496&quot;
  selfLink: /api/v1/namespaces/default/pods/my-pod
  uid: 27f1b2e1-3eb4-11e8-88d2-42010a800051
spec:
  containers:
  - image: nginx
    imagePullPolicy: Always
    name: nginx
    resources:
      requests:
        cpu: 100m
    terminationMessagePath: /dev/termination-log
    terminationMessagePolicy: File
[...]
</code></pre>
<p>These fields may represent materialized default values and other metadata
set by the API server, values set by built-in admission control or
external admission plugins, or even values set by other controllers.</p>
<p>Rather than sifting through all that to find the fields you care about,
<code>kubectl apply</code> lets you go back to your original, simple file,
and make a change:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-app
    role: staging # added a label
spec:
  containers:
    - name: nginx
      image: nginx
</code></pre>
<p>If you try to <code>kubectl create -f</code> your updated file, it will fail because
you can't create something that already exists.
If you try to <code>kubectl replace -f</code> your updated file, it will fail because
it thinks you're trying to unset all those extra fields.</p>
<p>However, if you use <code>kubectl apply -f</code> with your updated file,
it will update only the part you changed (adding a label),
and leave all those extra fields untouched.</p>
<p>Metacontroller treats the desired objects you return from your
hook in much the same way (but with <a href="api/apply.html#dynamic-apply">some differences</a>,
such as support for strategic merge inside CRDs).
As a result, you should always return the short form containing
only the fields you care about, not the long form containing
all the extra fields.</p>
<p>This generally means you should use the same code path to update things
as you do to create them.
Just generate a full JSON object from scratch every time,
containing all the fields you care about,
and only the fields you care about.</p>
<p>Metacontroller will figure out whether the object needs to be created
or updated, and which fields it should and shouldn't touch in the case
of an update.</p>
<h2 id="dynamic-apply"><a class="header" href="#dynamic-apply">Dynamic Apply</a></h2>
<p>The biggest difference between kubectl's implementation of apply
and Metacontroller's is that Metacontroller can emulate strategic
merge inside CRDs.</p>
<p>For example, suppose you have a CRD with an embedded Pod template:</p>
<pre><code class="language-yaml">apiVersion: ctl.enisoc.com/v1
kind: CatSet # this resource is served via CRD
metadata:
  name: my-catset
spec:
  template: # embedded Pod template in CRD
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx
          ports:
            - containerPort: 80
              name: web
</code></pre>
<p>You create this with apply:</p>
<pre><code class="language-sh">kubectl apply -f catset.yaml
</code></pre>
<p>The promise of <code>apply</code> is that it will &quot;apply the changes you’ve made, without overwriting any automated changes to properties you haven’t specified&quot;.</p>
<p>As an example, suppose some other automation decides to edit your Pod template
and add a sidecar container:</p>
<pre><code class="language-yaml">apiVersion: ctl.enisoc.com/v1
kind: CatSet # this resource is served via CRD
metadata:
  name: my-catset
spec:
  template: # embedded Pod template in CRD
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx
          ports:
            - containerPort: 80
              name: web
        - name: sidecar
          image: log-uploader # fake sidecar example
</code></pre>
<p>Now suppose you change something in your local file and reapply it:</p>
<pre><code class="language-sh">kubectl apply -f catset.yaml
</code></pre>
<p>Because <code>kubectl apply</code> doesn't support strategic merge inside CRDs,
this will completely replace the <code>containers</code> list with yours,
removing the <code>sidecar</code> container.
By contrast, if this had been a Deployment or StatefulSet,
<code>kubectl apply</code> would have preserved the <code>sidecar</code> container.</p>
<p>As a result, if a controller uses kubectl's apply implementation
with CRDs, that controller will fight against automation that tries
to add sidecar containers or makes other changes to lists of objects
that Kubernetes expects to be treated like associative arrays
(ports, volumes, etc.).</p>
<p>To avoid this fighting, and to make the experience of using CRDs beter match
that of native resources, Metacontroller uses an alternative implementation
of apply logic that's based on convention instead of configuration.</p>
<h3 id="conventions"><a class="header" href="#conventions">Conventions</a></h3>
<p>The main convention that Metacontroller enforces on apply semantics
is how to detect and handle &quot;associative lists&quot;.</p>
<p>In Kubernetes API conventions, an associative list is a list of objects
or scalars that should be treated as if it were a map (associative array),
but because of limitations in JSON/YAML it looks the same as an ordered list
when serialized.</p>
<p>For native resources, <code>kubectl apply</code> determines which lists are associative
lists by configuration: it must have compiled-in knowledge of all the resources,
and metadata about how each of their fields should be treated.
There is currently no mechanism for CRDs to specify this metadata,
which is why <code>kubectl apply</code> falls back to assuming all lists are &quot;atomic&quot;,
and should never be merged (only replaced entirely).</p>
<p>Even if there were a mechanism for CRDs to specify metadata for every field
(e.g. through extensions to OpenAPI),
it's not clear that it makes sense to <em>require</em> every CRD author to do so
in order for their resources to behave correctly when used with <code>kubecl apply</code>.
One alternative that has been considered for such &quot;schemaless CRDs&quot; is to
establish a convention -- as long as your CRD follows the convention, you
don't need to provide configuration.</p>
<p>Metacontroller implements one such convention that empirically handles
many common cases encountered when embedding Pod templates in CRDs
(although it has <a href="api/apply.html#limitations">limitations</a>),
developed by surveying the use of associative lists across the resources
built into Kubernetes:</p>
<ul>
<li>A list is detected as an associative list if and only if all of the
following conditions are met:
<ul>
<li>All items in the list are JSON objects
(not scalars, nor other lists).</li>
<li>All objects in the list have some field name in common,
where that field name is one of the conventional merge keys
(most commonly <code>name</code>).</li>
</ul>
</li>
<li>If a list is detected as an associative list, the conventional
field name that all objects have in common (e.g. <code>name</code>) is used
as the merge key.
<ul>
<li>If more than one conventional merge key might work,
pick only one according to a fixed order.</li>
</ul>
</li>
</ul>
<p>This allows Metacontroller to &quot;do the right thing&quot; in the majority of cases,
without requiring advance knowledge about the resources it's working with --
knowledge that's not available anywhere in the case of CRDs.</p>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p>A convention-based approach is necessarily more limiting than
the native apply implementation, which supports arbitrary per-field
configuration.
The trade-off is that conventions reduce boilerplate and lower the
barrier to entry for simple use cases.</p>
<p>This section lists some examples of configurations that the native
apply allows, but are currently not supported in Metacontroller's
convention-based apply.
If any of these are blockers for you,
please <a href="https://www.github.com/metacontroller/metacontroller/issues">file an issue</a> describing your
use case.</p>
<ul>
<li>Atomic object lists
<ul>
<li>A list of objects that share one of the conventional keys,
but should nevertheless be treated atomically (replaced rather than merged).</li>
</ul>
</li>
<li>Unconventional associative list keys
<ul>
<li>An associative list that doesn't use one of the conventional keys.</li>
</ul>
</li>
<li>Multi-field associative list keys
<ul>
<li>A key that's composed of two or more fields (e.g. both <code>port</code> and <code>protocol</code>).</li>
</ul>
</li>
<li>Scalar-valued associative lists
<ul>
<li>A list of scalars (not objects) that should be merged as if the
scalar values were field names in an object.</li>
</ul>
</li>
</ul>
<h2 id="server-side-apply"><a class="header" href="#server-side-apply">Server-Side Apply</a></h2>
<p>Server-side apply (SSA) is a Kubernetes-native declarative update mechanism that allows clients (e.g., controllers) to send a full object definition to the API server, which then manages field ownership and performs merges. Since SSA is a new feature for Metacontroller, it's advisable to use it with caution - especially in production environments - until you fully understand its implications and field ownership model.</p>
<p>SSA provides several advantages over client-side apply:</p>
<ul>
<li><strong>Field Ownership Tracking</strong>: The Kubernetes API server tracks which controller or user modified each field, preventing unintended overwrites.</li>
<li><strong>Strategic Merging</strong>: Unlike dynamic apply, SSA applies <strong>strategic merges</strong> even inside CRDs, similar to native Kubernetes resources.</li>
<li><strong>Better Handling of Concurrent Updates</strong>: SSA provides better conflict resolution when multiple controllers modify the same resource.</li>
</ul>
<h3 id="how-metacontroller-uses-server-side-apply"><a class="header" href="#how-metacontroller-uses-server-side-apply">How Metacontroller Uses Server-Side Apply</a></h3>
<p>When enabled, Metacontroller will:</p>
<ul>
<li>Use the <code>apply</code> verb with <code>server-side=true</code> when updating managed objects.</li>
<li>Allow multiple controllers to modify different fields of the same resource without conflicts.</li>
<li>Automatically merge updates to associative lists like <code>containers</code>, <code>volumes</code>, and <code>ports</code> without deleting unexpected changes.</li>
</ul>
<h3 id="example-of-server-side-apply"><a class="header" href="#example-of-server-side-apply">Example of Server-Side Apply</a></h3>
<p>Instead of performing a full replacement, SSA updates only the fields specified:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: my-app
    role: staging # added a label
spec:
  containers:
    - name: nginx
      image: nginx
</code></pre>
<p>When applied using SSA, Kubernetes ensures that fields like <code>resourceVersion</code>, <code>creationTimestamp</code>, and dynamically added containers (e.g., sidecars) <strong>remain untouched</strong>, unlike dynamic apply which would overwrite lists.</p>
<h3 id="comparison-dynamic-apply-vs-server-side-apply"><a class="header" href="#comparison-dynamic-apply-vs-server-side-apply">Comparison: Dynamic Apply vs. Server-Side Apply</a></h3>
<table><thead><tr><th>Feature</th><th>Dynamic Apply</th><th>Server-Side Apply (SSA)</th></tr></thead><tbody>
<tr><td>Merging of CRD fields</td><td>Uses conventions (e.g., <code>name</code> key)</td><td>Full strategic merge support</td></tr>
<tr><td>Field ownership</td><td>Not explicitly tracked</td><td>Kubernetes tracks field ownership</td></tr>
<tr><td>Concurrent updates</td><td>Risk of overwriting fields</td><td>Controlled conflict resolution</td></tr>
<tr><td>Associative lists</td><td>Convention-based merging</td><td>Kubernetes-native merging</td></tr>
<tr><td>Performance</td><td>Fast (no API tracking)</td><td>Slightly higher API overhead</td></tr>
</tbody></table>
<h3 id="enabling-server-side-apply"><a class="header" href="#enabling-server-side-apply">Enabling Server-Side Apply</a></h3>
<p>To enable SSA in Metacontroller, configure the controller with:</p>
<pre><code class="language-sh">--apply-strategy=server-side-apply
</code></pre>
<p>This setting ensures Metacontroller applies resources using Kubernetes-native <a href="https://kubernetes.io/docs/reference/using-api/server-side-apply"><code>server-side-apply</code></a> rather than dynamic apply.</p>
<h2 id="future-direction"><a class="header" href="#future-direction">Future Direction</a></h2>
<p>Previously, Metacontroller relied solely on a custom <strong>dynamic apply</strong> implementation to handle strategic merges within CRDs. However, with the introduction of Kubernetes <strong>server-side apply (SSA)</strong>, Metacontroller now supports SSA as a preferred alternative.</p>
<p>While <strong>dynamic apply</strong> remains available for compatibility, SSA is the recommended method for most use cases because it provides <strong>native field ownership tracking</strong>, <strong>strategic merging</strong>, and <strong>better concurrency handling</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compositecontroller-2"><a class="header" href="#compositecontroller-2">CompositeController</a></h1>
<p>CompositeController is an API provided by Metacontroller, designed to facilitate
custom controllers whose primary purpose is to manage a set of child objects
based on the desired state specified in a parent object.</p>
<p>Workload controllers like <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a> and <a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a> are examples of
existing controllers that fit this pattern.</p>
<p>This page is a detailed reference of all the features available in this API.
See the <a href="api/../guide/create.html">Create a Controller</a> guide for a step-by-step walkthrough.</p>
<ul>
<li><a href="api/compositecontroller.html#example">Example</a></li>
<li><a href="api/compositecontroller.html#spec">Spec</a></li>
<li><a href="api/compositecontroller.html#parent-resource">Parent Resource</a>
<ul>
<li><a href="api/compositecontroller.html#label-selector">Label Selector</a></li>
<li><a href="api/compositecontroller.html#revision-history">Revision History</a></li>
</ul>
</li>
<li><a href="api/compositecontroller.html#child-resources">Child Resources</a>
<ul>
<li><a href="api/compositecontroller.html#child-update-strategy">Child Update Strategy</a></li>
<li><a href="api/compositecontroller.html#child-update-methods">Child Update Methods</a></li>
<li><a href="api/compositecontroller.html#child-update-status-checks">Child Update Status Checks</a></li>
<li><a href="api/compositecontroller.html#status-condition-check">Status Condition Check</a></li>
</ul>
</li>
<li><a href="api/compositecontroller.html#resync-period">Resync Period</a></li>
<li><a href="api/compositecontroller.html#generate-selector">Generate Selector</a></li>
<li><a href="api/compositecontroller.html#hooks">Hooks</a>
<ul>
<li><a href="api/compositecontroller.html#sync-hook">Sync Hook</a>
<ul>
<li><a href="api/compositecontroller.html#sync-hook-request">Sync Hook Request</a></li>
<li><a href="api/compositecontroller.html#sync-hook-response">Sync Hook Response</a></li>
</ul>
</li>
<li><a href="api/compositecontroller.html#finalize-hook">Finalize Hook</a>
<ul>
<li><a href="api/compositecontroller.html#finalize-hook-request">Finalize Hook Request</a></li>
<li><a href="api/compositecontroller.html#finalize-hook-response">Finalize Hook Response</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="api/compositecontroller.html#customize-hook">Customize Hook</a></li>
</ul>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>This <a href="api/../examples.html#compositecontroller">example CompositeController</a>
defines a controller that behaves like StatefulSet.</p>
<pre><code class="language-yaml">apiVersion: metacontroller.k8s.io/v1alpha1
kind: CompositeController
metadata:
  name: catset-controller
spec:
  parentResource:
    apiVersion: ctl.enisoc.com/v1
    resource: catsets
    revisionHistory:
      fieldPaths:
      - spec.template
  childResources:
  - apiVersion: v1
    resource: pods
    updateStrategy:
      method: RollingRecreate
      statusChecks:
        conditions:
        - type: Ready
          status: &quot;True&quot;
  - apiVersion: v1
    resource: persistentvolumeclaims
  hooks:
    sync:
      webhook:
        url: http://catset-controller.metacontroller/sync
        timeout: 10s
</code></pre>
<h2 id="spec"><a class="header" href="#spec">Spec</a></h2>
<p>A CompositeController <code>spec</code> has the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="api/compositecontroller.html#parent-resource"><code>parentResource</code></a></td><td>A single resource rule specifying the parent resource.</td></tr>
<tr><td><a href="api/compositecontroller.html#child-resources"><code>childResources</code></a></td><td>A list of resource rules specifying the child resources.</td></tr>
<tr><td><a href="api/compositecontroller.html#resync-period"><code>resyncPeriodSeconds</code></a></td><td>How often, in seconds, you want every parent object to be resynced (sent to your hook), even if no changes are detected.</td></tr>
<tr><td><a href="api/compositecontroller.html#generate-selector"><code>generateSelector</code></a></td><td>If <code>true</code>, ignore the selector in each parent object and instead generate a unique selector that prevents overlap with other objects.</td></tr>
<tr><td><a href="api/compositecontroller.html#hooks"><code>hooks</code></a></td><td>A set of lambda hooks for defining your controller's behavior.</td></tr>
</tbody></table>
<h2 id="parent-resource"><a class="header" href="#parent-resource">Parent Resource</a></h2>
<p>The parent resource is the &quot;entry point&quot; for the CompositeController.
It should contain the information your controller needs to create
children, such as a Pod template if your controller creates Pods.
This is often a custom resource that you define (e.g. with CRD),
and for which you are now implementing a custom controller.</p>
<p>CompositeController expects to have full control over this resource.
That is, you shouldn't define a CompositeController with a parent
resource that already has its own controller.
See <a href="api/./decoratorcontroller.html">DecoratorController</a> for an API that's
better suited for adding behavior to existing resources.</p>
<p>The <code>parentResource</code> rule has the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>apiVersion</code></td><td>The API <code>&lt;group&gt;/&lt;version&gt;</code> of the parent resource, or just <code>&lt;version&gt;</code> for core APIs. (e.g. <code>v1</code>, <code>apps/v1</code>, <code>batch/v1</code>)</td></tr>
<tr><td><code>resource</code></td><td>The canonical, lowercase, plural name of the parent resource. (e.g. <code>deployments</code>, <code>replicasets</code>, <code>statefulsets</code>)</td></tr>
<tr><td><code>labelSelector</code></td><td>An optional label selector for narrowing down the objects to target. When not set defaults to all objects</td></tr>
<tr><td><a href="api/compositecontroller.html#revision-history"><code>revisionHistory</code></a></td><td>If any <a href="api/compositecontroller.html#child-resources">child resources</a> use rolling updates, this field specifies how parent revisions are tracked.</td></tr>
<tr><td><code>ignoreStatusChanges</code></td><td>An optional field through which status changes can be ignored for reconcilation. If set to <code>true</code>, only spec changes or labels/annotations changes will reconcile the parent resource.</td></tr>
</tbody></table>
<h3 id="label-selector"><a class="header" href="#label-selector">Label Selector</a></h3>
<p>Kubernetes APIs use <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">labels and selectors</a> to define subsets of
objects, such as the Pods managed by a given ReplicaSet.</p>
<p>The parent resource of a CompositeController is assumed to have a
<code>spec.selector</code> that matches the form of <code>spec.selector</code> in built-in resources
like Deployment and StatefulSet (with <code>matchLabels</code> and/or <code>matchExpressions</code>).</p>
<p>If the parent object doesn't have this field, or it can't be parsed in the
expected label selector format, the <a href="api/compositecontroller.html#sync-hook">sync hook</a> for
that parent will fail, unless you are using <a href="api/compositecontroller.html#generate-selector">selector generation</a>.</p>
<p>The parent's label selector determines which child objects a given parent
will try to manage, according to the <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/controller-ref.md#behavior">ControllerRef rules</a>.
Metacontroller automatically handles orphaning and adoption for you,
and will only send you the observed states of children you own.</p>
<p>These rules imply:</p>
<ul>
<li><strong>Children you create must have labels that satisfy the parent's selector</strong>,
or else they will be immediately orphaned and you'll never see them again.</li>
<li>If other controllers or users create orphaned objects that match the parent's
selector, Metacontroller will try to adopt them for you.</li>
<li>If Metacontroller adopts an object, and you subsequently decline to list that
object in your <a href="api/compositecontroller.html#sync-hook-response">desired list of children</a>,
it will get deleted (because you now own it, but said you don't want it).</li>
</ul>
<p>To avoid confusion, it's therefore important that users of your custom
controller specify a <code>spec.selector</code> (on each parent object) that is
sufficiently precise to discriminate its child objects from those of other
parents in the same namespace.</p>
<h3 id="revision-history"><a class="header" href="#revision-history">Revision History</a></h3>
<p>Within the <code>parentResource</code> rule, the <code>revisionHistory</code> field has the following subfields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>fieldPaths</code></td><td>A list of field path strings (e.g. <code>spec.template</code>) specifying which parent fields trigger rolling updates of children (for any <a href="api/compositecontroller.html#child-resources">child resources</a> that use rolling updates). Changes to other parent fields (e.g. <code>spec.replicas</code>) apply immediately. Defaults to <code>[&quot;spec&quot;]</code>, meaning any change in the parent's <code>spec</code> triggers a rolling update.</td></tr>
</tbody></table>
<h2 id="child-resources"><a class="header" href="#child-resources">Child Resources</a></h2>
<p>This list should contain a rule for every type of child resource
that your controller creates on behalf of each parent.</p>
<p>Each entry in the <code>childResources</code> list has the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>apiVersion</code></td><td>The API <code>group/version</code> of the child resource, or just <code>version</code> for core APIs. (e.g. <code>v1</code>, <code>apps/v1</code>, <code>batch/v1</code>)</td></tr>
<tr><td><code>resource</code></td><td>The canonical, lowercase, plural name of the child resource. (e.g. <code>deployments</code>, <code>replicasets</code>, <code>statefulsets</code>)</td></tr>
<tr><td><a href="api/compositecontroller.html#child-update-strategy"><code>updateStrategy</code></a></td><td>An optional field that specifies how to update children when they already exist but don't match your desired state. <strong>If no update strategy is specified, children of that type will never be updated if they already exist.</strong></td></tr>
</tbody></table>
<h3 id="child-update-strategy"><a class="header" href="#child-update-strategy">Child Update Strategy</a></h3>
<p>Within each rule in the <code>childResources</code> list, the <code>updateStrategy</code> field
has the following subfields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="api/compositecontroller.html#child-update-methods"><code>method</code></a></td><td>A string indicating the overall method that should be used for updating this type of child resource. <strong>The default is <code>OnDelete</code>, which means don't try to update children that already exist.</strong></td></tr>
<tr><td><a href="api/compositecontroller.html#child-update-status-checks"><code>statusChecks</code></a></td><td>If any rolling update method is selected, children that have already been updated must pass these status checks before the rollout will continue, please also read <a href="api/../guide/best-practices.html#Status">this section</a></td></tr>
</tbody></table>
<h3 id="child-update-methods"><a class="header" href="#child-update-methods">Child Update Methods</a></h3>
<p>Within each child resource's <code>updateStrategy</code>, the <code>method</code> field can have
these values:</p>
<table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>OnDelete</code></td><td>Don't update existing children unless they get deleted by some other agent.</td></tr>
<tr><td><code>Recreate</code></td><td>Immediately delete any children that differ from the desired state, and recreate them in the desired state.</td></tr>
<tr><td><code>InPlace</code></td><td>Immediately update any children that differ from the desired state.</td></tr>
<tr><td><code>RollingRecreate</code></td><td>Delete each child that differs from the desired state, one at a time, and recreate each child before moving on to the next one. Pause the rollout if at any time one of the children that have already been updated fails one or more <a href="api/compositecontroller.html#child-update-status-checks">status checks</a>.</td></tr>
<tr><td><code>RollingInPlace</code></td><td>Update each child that differs from the desired state, one at a time. Pause the rollout if at any time one of the children that have already been updated fails one or more <a href="api/compositecontroller.html#child-update-status-checks">status checks</a>.</td></tr>
</tbody></table>
<h3 id="child-update-status-checks"><a class="header" href="#child-update-status-checks">Child Update Status Checks</a></h3>
<p>Within each <code>updateStrategy</code>, the <code>statusChecks</code> field has the following subfields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="api/compositecontroller.html#status-condition-check"><code>conditions</code></a></td><td>A list of status condition checks that must all pass on already-updated children for the rollout to continue.</td></tr>
</tbody></table>
<h3 id="status-condition-check"><a class="header" href="#status-condition-check">Status Condition Check</a></h3>
<p>Within a set of <code>statusChecks</code>, each item in the <code>conditions</code> list has the following subfields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td>A string specifying the status condition <code>type</code> to check.</td></tr>
<tr><td><code>status</code></td><td>A string specifying the required <code>status</code> of the given status condition. If none is specified, the condition's <code>status</code> is not checked.</td></tr>
<tr><td><code>reason</code></td><td>A string specifying the required <code>reason</code> of the given status condition. If none is specified, the condition's <code>reason</code> is not checked.</td></tr>
</tbody></table>
<h2 id="resync-period"><a class="header" href="#resync-period">Resync Period</a></h2>
<p>By default, your <a href="api/compositecontroller.html#sync-hook">sync hook</a> will only be called when
something changes in one of the resources you're watching,
or when the <a href="api/../guide/configuration.html">local cache is flushed</a>.</p>
<p>Sometimes you may want to sync periodically even if nothing has
changed in the Kubernetes API objects, either to simply observe the passage
of time, or because your hook takes external state into account.
For example, CronJob uses a periodic resync to check whether it's time
to start a new Job.</p>
<p>The <code>resyncPeriodSeconds</code> value specifies how often to do this.
Each time it triggers, Metacontroller will send sync hook requests for
all objects of the parent resource type, with the latest observed
values of all the necessary objects.</p>
<p>Note that these objects will be retrieved from Metacontroller's local
cache (kept up-to-date through watches), so adding a resync shouldn't
add more load on the API server, unless you actually change objects.
For example, it's relatively cheap to use this setting to poll until
it's time to trigger some change, as long as most sync calls result in
a no-op (no CRUD operations needed to achieve desired state).</p>
<h2 id="generate-selector"><a class="header" href="#generate-selector">Generate Selector</a></h2>
<p>Usually, each parent object managed by a CompositeController must have its own
user-specified <a href="api/compositecontroller.html#label-selector">label selector</a>, just like each
Deployment has its own label selector in <code>spec.selector</code>.
However, sometimes it makes more sense to let the user of your API pretend there
are no labels or label selectors.</p>
<p>For example, the built-in <a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/">Job</a> API doesn't make you specify labels for your
Pods, and you can leave <code>spec.selector</code> unset.
Because each Job object represents a unique invocation at a point in time,
you wouldn't expect a newly-created Job to be satisfied by finding a
pre-existing Pod that just happens to have the right labels.
On the other hand, a ReplicaSet assumes all Pods that match its selector are
interchangeable, so it would be happy to have one less replica it has to create.</p>
<p>If you set <code>spec.generateSelector</code> to <code>true</code> in your CompositeController
definition, Metacontroller will do the following:</p>
<ul>
<li>When creating children for you, Metacontroller will automatically add a label
that points to the parent object's unique ID (<code>metadata.uid</code>).</li>
<li>Metacontroller will <em>not</em> expect each parent object to contain a
<code>spec.selector</code>, and will ignore the value even if one is set.</li>
<li>Metacontroller will manage children as if each parent object had an
&quot;imaginary&quot; label selector that points to the unique ID label that
Metacontroller added to all your children.</li>
</ul>
<p>The end result is that you and the users of your API don't have to think about
labels or selectors, similar to the Job API.
The downside is that your API won't support all the same capabilities as
built-in APIs.
For example, with ReplicaSet or StatefulSet, you can delete the controller with
<code>kubectl delete --cascade=false</code> to keep the Pods around, and later create a new
controller with the same selector to adopt those existing Pods instead of making
new ones from scratch.</p>
<h2 id="hooks"><a class="header" href="#hooks">Hooks</a></h2>
<p>Within the CompositeController <code>spec</code>, the <code>hooks</code> field has the following subfields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="api/compositecontroller.html#sync-hook"><code>sync</code></a></td><td>Specifies how to call your sync hook, if any.</td></tr>
<tr><td><a href="api/compositecontroller.html#finalize-hook"><code>finalize</code></a></td><td>Specifies how to call your finalize hook, if any.</td></tr>
<tr><td><a href="api/./customize.html#customize-hook"><code>customize</code></a></td><td>Specifies how to call your customize hook, if any.</td></tr>
</tbody></table>
<p>Each field of <code>hooks</code> contains <a href="api/./hook.html">subfields</a> that specify how to invoke
that hook, such as by sending a request to a <a href="api/./hook.html#webhook">webhook</a>.</p>
<h3 id="sync-hook"><a class="header" href="#sync-hook">Sync Hook</a></h3>
<p>The <code>sync</code> hook is how you specify which children to create/maintain
for a given parent -- in other words, your desired state.</p>
<p>Based on the CompositeController <a href="api/compositecontroller.html#spec">spec</a>, Metacontroller gathers up
all the resources you said you need to decide on the desired state,
and sends you their latest observed states.</p>
<p>After you return your desired state, Metacontroller begins to take action
to converge towards it -- creating, deleting, and updating objects as appropriate.</p>
<p>A simple way to think about your sync hook implementation is like a script
that generates JSON to be sent to <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#kubectl-apply"><code>kubectl apply</code></a>.
However, unlike a one-off client-side generator, your script has access to
the latest observed state in the cluster, and will automatically get called
any time that observed state changes.</p>
<h4 id="sync-hook-request"><a class="header" href="#sync-hook-request">Sync Hook Request</a></h4>
<p>A separate request will be sent for each parent object,
so your hook only needs to think about one parent at a time.</p>
<p>The body of the request (a POST in the case of a <a href="api/./hook.html#webhook">webhook</a>)
will be a JSON object with the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>controller</code></td><td>The whole CompositeController object, like what you might get from <code>kubectl get compositecontroller &lt;name&gt; -o json</code>.</td></tr>
<tr><td><code>parent</code></td><td>The parent object, like what you might get from <code>kubectl get &lt;parent-resource&gt; &lt;parent-name&gt; -o json</code>.</td></tr>
<tr><td><code>children</code></td><td>An associative array of child objects that already exist.</td></tr>
<tr><td><code>related</code></td><td>An associative array of related objects that exists, if <code>customize</code> hook was specified. See the <a href="api/./customize.html#customize-hook"><code>customize</code> hook</a></td></tr>
<tr><td><code>finalizing</code></td><td>This is always <code>false</code> for the <code>sync</code> hook. See the <a href="api/compositecontroller.html#finalize-hook"><code>finalize</code> hook</a> for details.</td></tr>
</tbody></table>
<p>Each field of the <code>children</code> object represents one of the types of <a href="api/compositecontroller.html#child-resources">child resources</a>
you specified in your CompositeController <a href="api/compositecontroller.html#spec">spec</a>.
The field name for each child type is <code>&lt;Kind&gt;.&lt;apiVersion&gt;</code>,
where <code>&lt;apiVersion&gt;</code> could be just <code>&lt;version&gt;</code> (for a core resource)
or <code>&lt;group&gt;/&lt;version&gt;</code>, just like you'd write in a YAML file.</p>
<p>For example, the field name for Pods would be <code>Pod.v1</code>,
while the field name for StatefulSets might be <code>StatefulSet.apps/v1</code>.</p>
<p>For resources that exist in multiple versions, the <code>apiVersion</code> you specify
in the <a href="api/compositecontroller.html#child-resources">child resource rule</a> is the one you'll be sent.
Metacontroller requires you to be explicit about the version you expect
because it does conversion for you as needed, so your hook doesn't need
to know how to convert between different versions of a given resource.</p>
<p>Within each child type (e.g. in <code>children['Pod.v1']</code>), there is another
associative array that maps from the child's path relative to the parent
to the JSON representation, like what you might get from
<code>kubectl get &lt;child-resource&gt; &lt;child-name&gt; -o json</code>.</p>
<p>If the parent and child are of the same scope - both cluster or both namespace -
then the key is only the child's <code>.metadata.name</code>. If the parent is
cluster scoped and the child is namespace scoped, then the key will be of the
form <code>{.metadata.namespace}/{.metadata.name}</code>. This is to disambiguate between
two children with the same name in different namespaces. A parent may never be
namespace scoped while a child is cluster scoped.</p>
<p>For example, a Pod named <code>my-pod</code> in the <code>my-namespace</code> namespace could be
accessed as follows if the parent is also in <code>my-namespace</code>:</p>
<pre><code class="language-js">request.children['Pod.v1']['my-pod']
</code></pre>
<p>Alternatively, if the parent resource is cluster scoped, the Pod could be
accessed as:</p>
<pre><code class="language-js">request.children['Pod.v1']['my-namespace/my-pod']
</code></pre>
<p>Note that you will only be sent children that you &quot;own&quot; according to the
<a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/controller-ref.md#behavior">ControllerRef rules</a>.
That means, for a given parent object, <strong>you will only see children whose
labels match the <a href="api/compositecontroller.html#label-selector">parent's label selector</a>, <em>and</em> that
don't belong to any other parent</strong>.</p>
<p>There will always be an entry in <code>children</code> for every <a href="api/compositecontroller.html#child-resources">child resource rule</a>,
even if no children of that type were observed at the time of the sync.
For example, if you listed Pods as a child resource rule, but no existing Pods
matched the parent's selector, you will receive:</p>
<pre><code class="language-json">{
  &quot;children&quot;: {
    &quot;Pod.v1&quot;: {}
  }
}
</code></pre>
<p>as opposed to:</p>
<pre><code class="language-json">{
  &quot;children&quot;: {}
}
</code></pre>
<p>Related resources, represented under <code>related</code> field, are present in the same form as <code>children</code>, 
but representing resources matching <code>customize</code> hook response for given <code>parent</code> object. 
Those object are not managed by controller, therefore are unmodificable, but you can use them to calculate <code>children</code>'s.
Some existing examples implementing this approach are :</p>
<ul>
<li>ConfigMapPropagation - makes copy of given ConfigMap in several namespaces.</li>
<li>GlobalConfigMap - makes copy of given ConfigMap in every namespace.</li>
<li>SecretPropagation - makes copy of given Secret in reach namespace satisfying label selector.</li>
</ul>
<p>Please note, than when related resources is updated, <code>sync</code> hook is triggered again (even if <code>parent</code> object and <code>children</code> does not change) - and you can recalculate
children state according to fresh view of related objects.</p>
<h4 id="sync-hook-response"><a class="header" href="#sync-hook-response">Sync Hook Response</a></h4>
<p>The body of your response should be a JSON object with the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>status</code></td><td>A JSON object that will completely replace the <code>status</code> field within the parent object.</td></tr>
<tr><td><code>children</code></td><td>A list of JSON objects representing all the desired children for this parent object.</td></tr>
<tr><td><code>resyncAfterSeconds</code></td><td>Set the delay (in seconds, as a float) before an optional, one-time, per-object resync.</td></tr>
</tbody></table>
<p>What you put in <code>status</code> is up to you, but usually it's best to follow
conventions established by controllers like Deployment.
You should compute <code>status</code> based only on the children that existed
when your hook was called; <strong>status represents a report on the last
observed state, not the new desired state</strong>.</p>
<p>The <code>children</code> field should contain a flat list of objects,
not an associative array.
Metacontroller groups the objects it sends you by type and name as a
convenience to simplify your scripts, but it's actually redundant
since each object contains its own <code>apiVersion</code>, <code>kind</code>, and <code>metadata.name</code>.</p>
<p>It's important to include the <code>apiVersion</code> and <code>kind</code> in objects
you return, and also to ensure that you list every type of
<a href="api/compositecontroller.html#child-resources">child resource</a> you plan to create in the
CompositeController spec.</p>
<p>If the parent resource is cluster scoped and the child resource is namespaced,
it's important to include the <code>.metadata.namespace</code> since the namespace cannot
be inferred from the parent's namespace.</p>
<p>Any objects sent as children in the request that you decline to return
in your response list <strong>will be deleted</strong>.
However, you shouldn't directly copy children from the request into the
response because they're in different forms.</p>
<p>Instead, you should think of each entry in the list of <code>children</code> as being
sent to <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#kubectl-apply"><code>kubectl apply</code></a>.
That is, you should <a href="api/./apply.html">set only the fields that you care about</a>.</p>
<p>You can optionally set <code>resyncAfterSeconds</code> to a value greater than 0 to request
that the <code>sync</code> hook be called again with this particular parent object after
some delay (specified in seconds, with decimal fractions allowed).
Unlike the controller-wide <a href="api/compositecontroller.html#resync-period"><code>resyncPeriodSeconds</code></a>, this is a
one-time request (not a request to start periodic resyncs), although you can
always return another <code>resyncAfterSeconds</code> value from subsequent <code>sync</code> calls.
Also unlike the controller-wide setting, this request only applies to the
particular parent object that this <code>sync</code> call sent, so you can request
different delays (or omit the request) depending on the state of each object.</p>
<p>Note that your webhook handler must return a response with a status code of <code>200</code>
to be considered successful. Metacontroller will wait for a response for up to the
amount defined in the <a href="api/./hook.html#webhook">Webhook spec</a>.</p>
<h3 id="finalize-hook"><a class="header" href="#finalize-hook">Finalize Hook</a></h3>
<p>If the <code>finalize</code> hook is defined, Metacontroller will add a finalizer to the
parent object, which will prevent it from being deleted until your hook has had
a chance to run and the response indicates that you're done cleaning up.</p>
<p>This is useful for doing ordered teardown of children, or for cleaning up
resources you may have created in an external system.
If you don't define a <code>finalize</code> hook, then when a parent object is deleted,
the garbage collector will delete all your children immediately,
and no hooks will be called.</p>
<p>The semantics of the <code>finalize</code> hook are mostly equivalent to those of
the <a href="api/compositecontroller.html#sync-hook"><code>sync</code> hook</a>.
Metacontroller will attempt to reconcile the desired states you return in the
<code>children</code> field, and will set <code>status</code> on the parent.
The main difference is that <code>finalize</code> will be called instead of <code>sync</code> when
it's time to clean up because the parent object is pending deletion.</p>
<p>Note that, just like <code>sync</code>, your <code>finalize</code> handler must be idempotent.
Metacontroller might call your hook multiple times as the observed state
changes, possibly even after you first indicate that you're done finalizing.
Your handler should know how to check what still needs to be done
and report success if there's nothing left to do.</p>
<p>Both <code>sync</code> and <code>finalize</code> have a request field called <code>finalizing</code> that
indicates which hook was actually called.
This lets you implement <code>finalize</code> either as a separate handler or as a check
within your <code>sync</code> handler, depending on how much logic they share.
To use the same handler for both, just define a <code>finalize</code> hook and set it to
the same value as your <code>sync</code> hook.</p>
<h4 id="finalize-hook-request"><a class="header" href="#finalize-hook-request">Finalize Hook Request</a></h4>
<p>The <code>finalize</code> hook request has all the same fields as the
<a href="api/compositecontroller.html#sync-hook-request"><code>sync</code> hook request</a>, with the following changes:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>finalizing</code></td><td>This is always <code>true</code> for the <code>finalize</code> hook. See the <a href="api/compositecontroller.html#finalize-hook"><code>finalize</code> hook</a> for details.</td></tr>
</tbody></table>
<p>If you share the same handler for both <code>sync</code> and <code>finalize</code>, you can use the
<code>finalizing</code> field to tell whether it's time to clean up or whether it's a
normal sync.
If you define a separate handler just for <code>finalize</code>, there's no need to check
the <code>finalizing</code> field since it will always be <code>true</code>.</p>
<h4 id="finalize-hook-response"><a class="header" href="#finalize-hook-response">Finalize Hook Response</a></h4>
<p>The <code>finalize</code> hook response has all the same fields as the
<a href="api/compositecontroller.html#sync-hook-response"><code>sync</code> hook response</a>, with the following additions:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>finalized</code></td><td>A boolean indicating whether you are done finalizing.</td></tr>
</tbody></table>
<p>To perform ordered teardown, you can generate children just like you would for
<code>sync</code>, but omit some children from the desired state depending on the observed
set of children that are left.
For example, if you observe <code>[A,B,C]</code>, generate only <code>[A,B]</code> as your desired
state; if you observe <code>[A,B]</code>, generate only <code>[A]</code>; if you observe <code>[A]</code>,
return an empty desired list <code>[]</code>.</p>
<p>Once the observed state passed in with the <code>finalize</code> request meets all your
criteria (e.g. no more children were observed), and you have checked all
other criteria (e.g. no corresponding external resource exists), return <code>true</code>
for the <code>finalized</code> field in your response.</p>
<p>Note that you should <em>not</em> return <code>finalized: true</code> the first time you return
a desired state that you consider &quot;final&quot;, since there's no guarantee that your
desired state will be reached immediately.
Instead, you should wait until the <em>observed</em> state matches what you want.</p>
<p>If the observed state passed in with the request doesn't meet your criteria,
you can return a successful response (HTTP code 200) with <code>finalized: false</code>,
and Metacontroller will call your hook again automatically if anything changes
in the observed state.</p>
<p>If the only thing you're still waiting for is a state change in an external
system, and you don't need to assert any new desired state for your children,
returning success from the <code>finalize</code> hook may mean that Metacontroller doesn't
call your hook again until the next <a href="api/compositecontroller.html#resync-period">periodic resync</a>.
To reduce the delay, you can request a one-time, per-object resync by setting
<code>resyncAfterSeconds</code> in your <a href="api/compositecontroller.html#sync-hook-response">hook response</a>, giving you
a chance to recheck the external state without holding up a slot in the work
queue.</p>
<h2 id="customize-hook"><a class="header" href="#customize-hook">Customize Hook</a></h2>
<p>See <a href="api/./customize.html#customize-hook">Customize hook spec</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="controllerrevision-1"><a class="header" href="#controllerrevision-1">ControllerRevision</a></h1>
<p>ControllerRevision is an internal API used by Metacontroller to implement
declarative rolling updates.</p>
<p>Users of Metacontroller normally shouldn't need to know about this API,
but it is documented here for Metacontroller <a href="api/../contrib.html">contributors</a>,
as well as for <a href="api/../guide/troubleshooting.html">troubleshooting</a>.</p>
<p>Note that this is different from the ControllerRevision in <code>apps/v1</code>,
although it serves a similar purpose.
You will likely need to use a fully-qualified resource name to inspect
Metacontroller's ControllerRevisions:</p>
<pre><code class="language-sh">kubectl get controllerrevisions.metacontroller.k8s.io
</code></pre>
<p>Each ControllerRevision's name is a combination of the name and API group
(excluding the version suffix) of the resource that it's a revision of,
as well as a hash that is deterministic yet unique (used only for idempotent
creation, not for lookup).</p>
<p>By default, ControllerRevisions belonging to a particular parent instance
will get garbage-collected if the parent is deleted.
However, it is possible to orphan ControllerRevisions during parent
deletion, and then create a replacement parent to adopt them.
ControllerRevisions are adopted based on the parent's label selector,
the same way controllers like ReplicaSet adopt Pods.</p>
<ul>
<li><a href="api/controllerrevision.html#example">Example</a></li>
<li><a href="api/controllerrevision.html#parent-patch">Parent Patch</a></li>
<li><a href="api/controllerrevision.html#children">Children</a></li>
</ul>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-yaml">apiVersion: metacontroller.k8s.io/v1alpha1
kind: ControllerRevision
metadata:
  name: catsets.ctl.enisoc.com-5463ba99b804a121d35d14a5ab74546d1e8ba953
  labels:
    app: nginx
    component: backend
    metacontroller.k8s.io/apiGroup: ctl.enisoc.com
    metacontroller.k8s.io/resource: catsets
parentPatch:
  spec:
    template:
      [...]
children:
- apiGroup: &quot;&quot;
  kind: Pod
  names:
  - nginx-backend-0
  - nginx-backend-1
  - nginx-backend-2
</code></pre>
<h2 id="parent-patch"><a class="header" href="#parent-patch">Parent Patch</a></h2>
<p>The <code>parentPatch</code> field stores a partial representation of the parent object
at a given revision, containing only those fields listed by the lambda controller
author as participating in rolling updates.</p>
<p>For example, if a CompositeController's <a href="api/./compositecontroller.html#revision-history">revision history</a> specifies
a <code>fieldPaths</code> list of <code>[&quot;spec.template&quot;]</code>, the parent patch will contain
only <code>spec.template</code> and any subfields nested within it.</p>
<p>This mirrors the selective behavior of rolling updates in built-in APIs
like Deployment and StatefulSet.
Any fields that aren't part of the parent patch take effect immediately,
rather than rolling out gradually.</p>
<h2 id="children"><a class="header" href="#children">Children</a></h2>
<p>The <code>children</code> field stores a list of child objects that &quot;belong&quot; to this
particular revision of the parent.</p>
<p>This is how Metacontroller keeps track of the current desired revision of
a given child.
For example, if a Pod that hasn't been updated yet gets deleted by a Node
drain, it should be replaced at the revision it was on before it got deleted,
not at the latest revision.</p>
<p>When Metacontroller decides it's time to update a given child to another
revision, it first records this intention by updating the relevant
ControllerRevision objects.
After committing these records, it then begins updating that child according
to the configured <a href="api/./compositecontroller.html#child-update-strategy">child update strategy</a>.
This ensures that the intermediate progress of the rollout is persisted
in the API server so it survives process restarts.</p>
<p>Children are grouped by API Group (excluding the version suffix) and Kind.
For each Group-Kind, we store a list of object names.
Note that parent and children must be in the same namespace,
and ControllerRevisions for a given parent also live in that
parent's namespace.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decoratorcontroller-2"><a class="header" href="#decoratorcontroller-2">DecoratorController</a></h1>
<p>DecoratorController is an API provided by Metacontroller, designed to facilitate
adding new behavior to existing resources. You can define rules for which
resources to watch, as well as filters on labels and annotations.</p>
<p>This page is a detailed reference of all the features available in this API.
See the <a href="api/../guide/create.html">Create a Controller</a> guide for a step-by-step walkthrough.</p>
<ul>
<li><a href="api/decoratorcontroller.html#example">Example</a></li>
<li><a href="api/decoratorcontroller.html#spec">Spec</a></li>
<li><a href="api/decoratorcontroller.html#resources">Resources</a>
<ul>
<li><a href="api/decoratorcontroller.html#label-selector">Label Selector</a></li>
<li><a href="api/decoratorcontroller.html#annotation-selector">Annotation Selector</a></li>
</ul>
</li>
<li><a href="api/decoratorcontroller.html#attachments">Attachments</a>
<ul>
<li><a href="api/decoratorcontroller.html#attachment-update-strategy">Attachment Update Strategy</a></li>
<li><a href="api/decoratorcontroller.html#attachment-update-methods">Attachment Update Methods</a></li>
</ul>
</li>
<li><a href="api/decoratorcontroller.html#resync-period">Resync Period</a></li>
<li><a href="api/decoratorcontroller.html#hooks">Hooks</a>
<ul>
<li><a href="api/decoratorcontroller.html#sync-hook">Sync Hook</a>
<ul>
<li><a href="api/decoratorcontroller.html#sync-hook-request">Sync Hook Request</a></li>
<li><a href="api/decoratorcontroller.html#sync-hook-response">Sync Hook Response</a></li>
</ul>
</li>
<li><a href="api/decoratorcontroller.html#finalize-hook">Finalize Hook</a>
<ul>
<li><a href="api/decoratorcontroller.html#finalize-hook-request">Finalize Hook Request</a></li>
<li><a href="api/decoratorcontroller.html#finalize-hook-response">Finalize Hook Response</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="api/decoratorcontroller.html#customize-hook">Customize Hook</a></li>
</ul>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<p>This <a href="api/../examples.html#decoratorcontroller">example DecoratorController</a>
attaches a Service for each Pod belonging to a StatefulSet,
for any StatefulSet that requests this behavior through a set of
annotations.</p>
<pre><code class="language-yaml">apiVersion: metacontroller.k8s.io/v1alpha1
kind: DecoratorController
metadata:
  name: service-per-pod
spec:
  resources:
  - apiVersion: apps/v1
    resource: statefulsets
    annotationSelector:
      matchExpressions:
      - {key: service-per-pod-label, operator: Exists}
      - {key: service-per-pod-ports, operator: Exists}
  attachments:
  - apiVersion: v1
    resource: services
  hooks:
    sync:
      webhook:
        url: http://service-per-pod.metacontroller/sync-service-per-pod
        timeout: 10s
</code></pre>
<h2 id="spec-1"><a class="header" href="#spec-1">Spec</a></h2>
<p>A DecoratorController <code>spec</code> has the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="api/decoratorcontroller.html#resources"><code>resources</code></a></td><td>A list of resource rules specifying which objects to target for decoration (adding behavior).</td></tr>
<tr><td><a href="api/decoratorcontroller.html#attachments"><code>attachments</code></a></td><td>A list of resource rules specifying what this decorator can attach to the target resources.</td></tr>
<tr><td><a href="api/decoratorcontroller.html#resync-period"><code>resyncPeriodSeconds</code></a></td><td>How often, in seconds, you want every target object to be resynced (sent to your hook), even if no changes are detected.</td></tr>
<tr><td><a href="api/decoratorcontroller.html#hooks"><code>hooks</code></a></td><td>A set of lambda hooks for defining your controller's behavior.</td></tr>
</tbody></table>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p>Each DecoratorController can target one or more types of resources.
For every object that matches one of these rules, Metacontroller will
call your <a href="api/decoratorcontroller.html#sync-hook">sync hook</a> to ask for your desired state.</p>
<p>Each entry in the <code>resources</code> list has the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>apiVersion</code></td><td>The API <code>&lt;group&gt;/&lt;version&gt;</code> of the target resource, or just <code>&lt;version&gt;</code> for core APIs. (e.g. <code>v1</code>, <code>apps/v1</code>, <code>batch/v1</code>)</td></tr>
<tr><td><code>resource</code></td><td>The canonical, lowercase, plural name of the target resource. (e.g. <code>deployments</code>, <code>replicasets</code>, <code>statefulsets</code>)</td></tr>
<tr><td><a href="api/decoratorcontroller.html#label-selector"><code>labelSelector</code></a></td><td>An optional label selector for narrowing down the objects to target.</td></tr>
<tr><td><a href="api/decoratorcontroller.html#annotation-selector"><code>annotationSelector</code></a></td><td>An optional annotation selector for narrowing down the objects to target.</td></tr>
<tr><td><code>ignoreStatusChanges</code></td><td>An optional field through which status changes can be ignored for reconcilation. If set to <code>true</code>, only spec changes or labels/annotations changes will reconcile the parent resource.</td></tr>
</tbody></table>
<h3 id="label-selector-1"><a class="header" href="#label-selector-1">Label Selector</a></h3>
<p>The <code>labelSelector</code> field within a <a href="api/decoratorcontroller.html#resources">resource rule</a> has the following subfields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>matchLabels</code></td><td>A map of key-value pairs representing labels that must exist and have the specified values in order for an object to satisfy the selector.</td></tr>
<tr><td><code>matchExpressions</code></td><td>A list of <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#resources-that-support-set-based-requirements">set-based requirements</a> on labels in order for an object to satisfy the selector.</td></tr>
</tbody></table>
<p>This label selector has the same format and semantics as the selector in
built-in APIs like Deployment.</p>
<p>If a <code>labelSelector</code> is specified for a given resource type,
the DecoratorController will ignore any objects of that type
that don't satisfy the selector.</p>
<p>If a resource rule has both a <code>labelSelector</code> and an <code>annotationSelector</code>,
the DecoratorController will only target objects of that type that satisfy
<em>both</em> selectors.</p>
<h3 id="annotation-selector"><a class="header" href="#annotation-selector">Annotation Selector</a></h3>
<p>The <code>annotationSelector</code> field within a <a href="api/decoratorcontroller.html#resources">resource rule</a> has the following subfields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>matchAnnotations</code></td><td>A map of key-value pairs representing annotations that must exist and have the specified values in order for an object to satisfy the selector.</td></tr>
<tr><td><code>matchExpressions</code></td><td>A list of <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#resources-that-support-set-based-requirements">set-based requirements</a> on annotations in order for an object to satisfy the selector.</td></tr>
</tbody></table>
<p>The annotation selector has an analogous format and semantics to the
<a href="api/decoratorcontroller.html#label-selector">label selector</a> (note the field name <code>matchAnnotations</code>
rather than <code>matchLabels</code>).</p>
<p>If an <code>annotationSelector</code> is specified for a given resource type,
the DecoratorController will ignore any objects of that type
that don't satisfy the selector.</p>
<p>If a resource rule has both a <code>labelSelector</code> and an <code>annotationSelector</code>,
the DecoratorController will only target objects of that type that satisfy
<em>both</em> selectors.</p>
<h2 id="attachments"><a class="header" href="#attachments">Attachments</a></h2>
<p>This list should contain a rule for every type of resource
your controller wants to attach to an object of one of the
<a href="api/decoratorcontroller.html#resources">targeted resources</a>.</p>
<p>Unlike <a href="api/./compositecontroller.html#child-resources">child resources in CompositeController</a>,
attachments are <em>not</em> related to the target object through
labels and label selectors.
This allows you to attach arbitrary things (which may not have any labels)
to other arbitrary things (which may not even have a selector).</p>
<p>Instead, attachments are only connected to the target object
through owner references, meaning they will get cleaned up
if the target object is deleted.</p>
<p>Each entry in the <code>attachments</code> list has the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>apiVersion</code></td><td>The API <code>group/version</code> of the attached resource, or just <code>version</code> for core APIs. (e.g. <code>v1</code>, <code>apps/v1</code>, <code>batch/v1</code>)</td></tr>
<tr><td><code>resource</code></td><td>The canonical, lowercase, plural name of the attached resource. (e.g. <code>deployments</code>, <code>replicasets</code>, <code>statefulsets</code>)</td></tr>
<tr><td><a href="api/decoratorcontroller.html#attachment-update-strategy"><code>updateStrategy</code></a></td><td>An optional field that specifies how to update attachments when they already exist but don't match your desired state. <strong>If no update strategy is specified, attachments of that type will never be updated if they already exist.</strong></td></tr>
</tbody></table>
<h3 id="attachment-update-strategy"><a class="header" href="#attachment-update-strategy">Attachment Update Strategy</a></h3>
<p>Within each rule in the <code>attachments</code> list, the <code>updateStrategy</code> field
has the following subfields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="api/decoratorcontroller.html#attachment-update-methods"><code>method</code></a></td><td>A string indicating the overall method that should be used for updating this type of attachment resource. <strong>The default is <code>OnDelete</code>, which means don't try to update attachments that already exist.</strong></td></tr>
</tbody></table>
<h3 id="attachment-update-methods"><a class="header" href="#attachment-update-methods">Attachment Update Methods</a></h3>
<p>Within each attachment resource's <code>updateStrategy</code>, the <code>method</code> field can have
these values:</p>
<table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>OnDelete</code></td><td>Don't update existing attachments unless they get deleted by some other agent.</td></tr>
<tr><td><code>Recreate</code></td><td>Immediately delete any attachments that differ from the desired state, and recreate them in the desired state.</td></tr>
<tr><td><code>InPlace</code></td><td>Immediately update any attachments that differ from the desired state.</td></tr>
</tbody></table>
<p>Note that DecoratorController doesn't directly support rolling update
of attachments because you can compose such behavior by attaching
a <a href="api/./compositecontroller.html">CompositeController</a>
(or any other API that supports declarative rolling update,
like Deployment or StatefulSet).</p>
<h2 id="resync-period-1"><a class="header" href="#resync-period-1">Resync Period</a></h2>
<p>The <code>resyncPeriodSeconds</code> field in DecoratorController's <code>spec</code>
works similarly to the same field in
<a href="api/./compositecontroller.html#resync-period">CompositeController</a>.</p>
<h2 id="hooks-1"><a class="header" href="#hooks-1">Hooks</a></h2>
<p>Within the DecoratorController <code>spec</code>, the <code>hooks</code> field has the following subfields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="api/decoratorcontroller.html#sync-hook"><code>sync</code></a></td><td>Specifies how to call your sync hook, if any.</td></tr>
<tr><td><a href="api/decoratorcontroller.html#finalize-hook"><code>finalize</code></a></td><td>Specifies how to call your finalize hook, if any.</td></tr>
<tr><td><a href="api/./customize.html#customize-hook"><code>customize</code></a></td><td>Specifies how to call your customize hook, if any.</td></tr>
</tbody></table>
<p>Each field of <code>hooks</code> contains <a href="api/./hook.html">subfields</a> that specify how to invoke
that hook, such as by sending a request to a <a href="api/./hook.html#webhook">webhook</a>.</p>
<h3 id="sync-hook-1"><a class="header" href="#sync-hook-1">Sync Hook</a></h3>
<p>The <code>sync</code> hook is how you specify which attachments to create/maintain
for a given target object -- in other words, your desired state.</p>
<p>Based on the DecoratorController <a href="api/decoratorcontroller.html#spec">spec</a>, Metacontroller gathers up
all the resources you said you need to decide on the desired state,
and sends you their latest observed states.</p>
<p>After you return your desired state, Metacontroller begins to take action
to converge towards it -- creating, deleting, and updating objects as appropriate.</p>
<p>A simple way to think about your sync hook implementation is like a script
that generates JSON to be sent to <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#kubectl-apply"><code>kubectl apply</code></a>.
However, unlike a one-off client-side generator, your script has access to
the latest observed state in the cluster, and will automatically get called
any time that observed state changes.</p>
<h4 id="sync-hook-request-1"><a class="header" href="#sync-hook-request-1">Sync Hook Request</a></h4>
<p>A separate request will be sent for each target object,
so your hook only needs to think about one target object at a time.</p>
<p>The body of the request (a POST in the case of a <a href="api/./hook.html#webhook">webhook</a>)
will be a JSON object with the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>controller</code></td><td>The whole DecoratorController object, like what you might get from <code>kubectl get decoratorcontroller &lt;name&gt; -o json</code>.</td></tr>
<tr><td><code>object</code></td><td>The target object, like what you might get from <code>kubectl get &lt;target-resource&gt; &lt;target-name&gt; -o json</code>.</td></tr>
<tr><td><code>attachments</code></td><td>An associative array of attachments that already exist.</td></tr>
<tr><td><code>related</code></td><td>An associative array of related objects that exists, if <code>customize</code> hook was specified. See the <a href="api/./customize.html#customize-hook"><code>customize</code> hook</a></td></tr>
<tr><td><code>finalizing</code></td><td>This is always <code>false</code> for the <code>sync</code> hook. See the <a href="api/decoratorcontroller.html#finalize-hook"><code>finalize</code> hook</a> for details.</td></tr>
</tbody></table>
<p>Each field of the <code>attachments</code> object represents one of the types of
<a href="api/decoratorcontroller.html#attachments">attachment resources</a> in your DecoratorController <a href="api/decoratorcontroller.html#spec">spec</a>.
The field name for each attachment type is <code>&lt;Kind&gt;.&lt;apiVersion&gt;</code>,
where <code>&lt;apiVersion&gt;</code> could be just <code>&lt;version&gt;</code> (for a core resource)
or <code>&lt;group&gt;/&lt;version&gt;</code>, just like you'd write in a YAML file.</p>
<p>For example, the field name for Pods would be <code>Pod.v1</code>,
while the field name for StatefulSets might be <code>StatefulSet.apps/v1</code>.</p>
<p>For resources that exist in multiple versions, the <code>apiVersion</code> you specify
in the <a href="api/decoratorcontroller.html#attachments">attachment resource rule</a> is the one you'll be sent.
Metacontroller requires you to be explicit about the version you expect
because it does conversion for you as needed, so your hook doesn't need
to know how to convert between different versions of a given resource.</p>
<p>Within each attachment type (e.g. in <code>attachments['Pod.v1']</code>), there is another
associative array that maps from the attachment's path relative to the parent to
the JSON representation, like what you might get from
<code>kubectl get &lt;attachment-resource&gt; &lt;attachment-name&gt; -o json</code>.</p>
<p>If the parent and attachment are of the same scope - both cluster or both namespace -
then the key is only the object's <code>.metadata.name</code>. If the parent is
cluster scoped and the attachment is namespace scoped, then the key will be of the
form <code>{.metadata.namespace}/{.metadata.name}</code>. This is to disambiguate between
two attachments with the same name in different namespaces. A parent may never
be namespace scoped while an attachment is cluster scoped.</p>
<p>For example, a Pod named <code>my-pod</code> in the <code>my-namespace</code> namespace could be
accessed as follows if the parent is also in <code>my-namespace</code>:</p>
<pre><code class="language-js">request.attachments['Pod.v1']['my-pod']
</code></pre>
<p>Alternatively, if the parent resource is cluster scoped, the Pod could be
accessed as:</p>
<pre><code class="language-js">request.attachments['Pod.v1']['my-namespace/my-pod']
</code></pre>
<p>Note that you will only be sent objects that are owned by the target
(i.e. objects you attached), not all objects of that resource type.</p>
<p>There will always be an entry in <code>attachments</code> for every <a href="api/decoratorcontroller.html#attachments">attachment resource rule</a>,
even if no attachments of that type were observed at the time of the sync.
For example, if you listed Pods as an attachment resource rule,
but no existing Pods have been attached, you will receive:</p>
<pre><code class="language-json">{
  &quot;attachments&quot;: {
    &quot;Pod.v1&quot;: {}
  }
}
</code></pre>
<p>as opposed to:</p>
<pre><code class="language-json">{
  &quot;attachments&quot;: {}
}
</code></pre>
<p>Related resources, represented under <code>related</code> field, are present in the same form as <code>attachements</code>, 
but representing resources matching <code>customize</code> hook response for given <code>parent</code> object. 
Those object are not managed by controller, therefore are unmodificable, but you can use them to calculate <code>attachements</code>.
Some existing examples implementing this approach are :</p>
<ul>
<li>ConfigMapPropagation - makes copy of given ConfigMap in several namespaces.</li>
<li>GlobalConfigMap - makes copy of given ConfigMap in every namespace.</li>
<li>SecretPropagation - makes copy of given Secret in reach namespace satisfying label selector.</li>
</ul>
<p>Please note, than when related resources is updated, <code>sync</code> hook is triggered again (even if <code>parent</code> object and <code>attachements</code> does not change) - and you can recalculate
children state according to fresh view of related objects.</p>
<h4 id="sync-hook-response-1"><a class="header" href="#sync-hook-response-1">Sync Hook Response</a></h4>
<p>The body of your response should be a JSON object with the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>labels</code></td><td>A map of key-value pairs for labels to set on the target object.</td></tr>
<tr><td><code>annotations</code></td><td>A map of key-value pairs for annotations to set on the target object.</td></tr>
<tr><td><code>status</code></td><td>A JSON object that will completely replace the <code>status</code> field within the target object. Leave unspecified or <code>null</code> to avoid changing <code>status</code>.</td></tr>
<tr><td><code>attachments</code></td><td>A list of JSON objects representing all the desired attachments for this target object.</td></tr>
<tr><td><code>resyncAfterSeconds</code></td><td>Set the delay (in seconds, as a float) before an optional, one-time, per-object resync.</td></tr>
</tbody></table>
<p>By convention, the controller for a given resource should not
modify its own spec, so your decorator can't mutate the target's spec.</p>
<p>As a result, decorators currently cannot modify the target object except
to optionally set labels, annotations, and status on it.
Note that if the target resource already has its own controller,
that controller might ignore and overwrite any status updates you make.</p>
<p>The <code>attachments</code> field should contain a flat list of objects,
not an associative array.
Metacontroller groups the objects it sends you by type and name as a
convenience to simplify your scripts, but it's actually redundant
since each object contains its own <code>apiVersion</code>, <code>kind</code>, and <code>metadata.name</code>.</p>
<p>It's important to include the <code>apiVersion</code> and <code>kind</code> in objects
you return, and also to ensure that you list every type of
<a href="api/decoratorcontroller.html#attachments">attachment resource</a> you plan to create in the
DecoratorController spec.</p>
<p>If the parent resource is cluster scoped and the child resource is namespaced,
it's important to include the <code>.metadata.namespace</code> since the namespace cannot
be inferred from the parent's namespace.</p>
<p>Any objects sent as attachments in the request that you decline to return
in your response list <strong>will be deleted</strong>.
However, you shouldn't directly copy attachments from the request into the
response because they're in different forms.</p>
<p>Instead, you should think of each entry in the list of <code>attachments</code> as being
sent to <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#kubectl-apply"><code>kubectl apply</code></a>.
That is, you should <a href="api/./apply.html">set only the fields that you care about</a>.</p>
<p>You can optionally set <code>resyncAfterSeconds</code> to a value greater than 0 to request
that the <code>sync</code> hook be called again with this particular parent object after
some delay (specified in seconds, with decimal fractions allowed).
Unlike the controller-wide <a href="api/decoratorcontroller.html#resync-period"><code>resyncPeriodSeconds</code></a>, this is a
one-time request (not a request to start periodic resyncs), although you can
always return another <code>resyncAfterSeconds</code> value from subsequent <code>sync</code> calls.
Also unlike the controller-wide setting, this request only applies to the
particular parent object that this <code>sync</code> call sent, so you can request
different delays (or omit the request) depending on the state of each object.</p>
<p>Note that your webhook handler must return a response with a status code of <code>200</code>
to be considered successful. Metacontroller will wait for a response for up to the
amount defined in the <a href="api/./hook.html#webhook">Webhook spec</a>.</p>
<h3 id="finalize-hook-1"><a class="header" href="#finalize-hook-1">Finalize Hook</a></h3>
<p>If the <code>finalize</code> hook is defined, Metacontroller will add a finalizer to the
parent object, which will prevent it from being deleted until your hook has had
a chance to run and the response indicates that you're done cleaning up.</p>
<p>This is useful for doing ordered teardown of attachments, or for cleaning up
resources you may have created in an external system.
If you don't define a <code>finalize</code> hook, then when a parent object is deleted,
the garbage collector will delete all your attachments immediately,
and no hooks will be called.</p>
<p>In addition to finalizing when an object is deleted, Metacontroller will also
call your <code>finalize</code> hook on objects that were previously sent to <code>sync</code>
but now no longer match the DecoratorController's label and annotation selectors.
This allows you to clean up after yourself when the object has been updated to
opt out of the functionality added by your decorator, even if the object is not
being deleted.
If you don't define a <code>finalize</code> hook, then when the object opts out, any
attachments you added will remain until the object is deleted,
and no hooks will be called.</p>
<p>The semantics of the <code>finalize</code> hook are mostly equivalent to those of
the <a href="api/decoratorcontroller.html#sync-hook"><code>sync</code> hook</a>.
Metacontroller will attempt to reconcile the desired states you return in the
<code>attachments</code> field, and will set labels and annotations as requested.
The main difference is that <code>finalize</code> will be called instead of <code>sync</code> when
it's time to clean up because the parent object is pending deletion.</p>
<p>Note that, just like <code>sync</code>, your <code>finalize</code> handler must be idempotent.
Metacontroller might call your hook multiple times as the observed state
changes, possibly even after you first indicate that you're done finalizing.
Your handler should know how to check what still needs to be done
and report success if there's nothing left to do.</p>
<p>Both <code>sync</code> and <code>finalize</code> have a request field called <code>finalizing</code> that
indicates which hook was actually called.
This lets you implement <code>finalize</code> either as a separate handler or as a check
within your <code>sync</code> handler, depending on how much logic they share.
To use the same handler for both, just define a <code>finalize</code> hook and set it to
the same value as your <code>sync</code> hook.</p>
<h4 id="finalize-hook-request-1"><a class="header" href="#finalize-hook-request-1">Finalize Hook Request</a></h4>
<p>The <code>finalize</code> hook request has all the same fields as the
<a href="api/decoratorcontroller.html#sync-hook-request"><code>sync</code> hook request</a>, with the following changes:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>finalizing</code></td><td>This is always <code>true</code> for the <code>finalize</code> hook. See the <a href="api/decoratorcontroller.html#finalize-hook"><code>finalize</code> hook</a> for details.</td></tr>
</tbody></table>
<p>If you share the same handler for both <code>sync</code> and <code>finalize</code>, you can use the
<code>finalizing</code> field to tell whether it's time to clean up or whether it's a
normal sync.
If you define a separate handler just for <code>finalize</code>, there's no need to check
the <code>finalizing</code> field since it will always be <code>true</code>.</p>
<h4 id="finalize-hook-response-1"><a class="header" href="#finalize-hook-response-1">Finalize Hook Response</a></h4>
<p>The <code>finalize</code> hook response has all the same fields as the
<a href="api/decoratorcontroller.html#sync-hook-response"><code>sync</code> hook response</a>, with the following additions:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>finalized</code></td><td>A boolean indicating whether you are done finalizing.</td></tr>
</tbody></table>
<p>To perform ordered teardown, you can generate attachments just like you would for
<code>sync</code>, but omit some attachments from the desired state depending on the observed
set of attachments that are left.
For example, if you observe <code>[A,B,C]</code>, generate only <code>[A,B]</code> as your desired
state; if you observe <code>[A,B]</code>, generate only <code>[A]</code>; if you observe <code>[A]</code>,
return an empty desired list <code>[]</code>.</p>
<p>Once the observed state passed in with the <code>finalize</code> request meets all your
criteria (e.g. no more attachments were observed), and you have checked all
other criteria (e.g. no corresponding external resource exists), return <code>true</code>
for the <code>finalized</code> field in your response.</p>
<p>Note that you should <em>not</em> return <code>finalized: true</code> the first time you return
a desired state that you consider &quot;final&quot;, since there's no guarantee that your
desired state will be reached immediately.
Instead, you should wait until the <em>observed</em> state matches what you want.</p>
<p>If the observed state passed in with the request doesn't meet your criteria,
you can return a successful response (HTTP code 200) with <code>finalized: false</code>,
and Metacontroller will call your hook again automatically if anything changes
in the observed state.</p>
<p>If the only thing you're still waiting for is a state change in an external
system, and you don't need to assert any new desired state for your children,
returning success from the <code>finalize</code> hook may mean that Metacontroller doesn't
call your hook again until the next <a href="api/decoratorcontroller.html#resync-period">periodic resync</a>.
To reduce the delay, you can request a one-time, per-object resync by setting
<code>resyncAfterSeconds</code> in your <a href="api/decoratorcontroller.html#sync-hook-response">hook response</a>, giving you
a chance to recheck the external state without holding up a slot in the work
queue.</p>
<h2 id="customize-hook-1"><a class="header" href="#customize-hook-1">Customize Hook</a></h2>
<p>See <a href="api/./customize.html#customize-hook">Customize hook spec</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customize-hook-2"><a class="header" href="#customize-hook-2">Customize Hook</a></h1>
<p>If the customize hook is defined, Metacontroller will ask for which related objects, or classes of objects that your sync and finalize hooks need to know about.
This is useful for mapping across many objects. One example would be a controller that lets you specify ConfigMaps to be placed in every Namespace.
Another use-case is being able to reference other objects, e.g. the env section from a core Pod object.
If you don't define a customize hook, then the related section of the hooks will be empty.</p>
<p>The <code>customize</code> hook will not provide any information about the current state of
the cluster. Thus, the set of related objects may only depend on the state of
the parent object.</p>
<p>This hook may also accept other fields in future, for other customizations.</p>
<ul>
<li><a href="api/customize.html#customize-hook-request">Customize Hook Request</a></li>
<li><a href="api/customize.html#customize-hook-response">Customize Hook Response</a></li>
<li><a href="api/customize.html#example">Example</a></li>
</ul>
<h2 id="customize-hook-request"><a class="header" href="#customize-hook-request">Customize Hook Request</a></h2>
<p>A separate request will be sent for each parent object,
so your hook only needs to think about one parent at a time.</p>
<p>The body of the request (a POST in the case of a <a href="api/../api/hook.html#webhook">webhook</a>)
will be a JSON object with the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>controller</code></td><td>The whole CompositeController object, like what you might get from <code>kubectl get compositecontroller &lt;name&gt; -o json</code>.</td></tr>
<tr><td><code>parent</code></td><td>The parent object, like what you might get from <code>kubectl get &lt;parent-resource&gt; &lt;parent-name&gt; -o json</code>.</td></tr>
</tbody></table>
<h2 id="customize-hook-response"><a class="header" href="#customize-hook-response">Customize Hook Response</a></h2>
<p>The body of your response should be a JSON object with the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>relatedResources</code></td><td>A list of JSON objects (<code>ResourceRules</code>) representing all the desired related resource descriptions ().</td></tr>
</tbody></table>
<p>The <code>relatedResources</code> field should contain a flat list of objects,
not an associative array.</p>
<p>Each <code>ResourceRule</code> object should be a JSON object with the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>apiVersion</code></td><td>The API <code>&lt;group&gt;/&lt;version&gt;</code> of the parent resource, or just <code>&lt;version&gt;</code> for core APIs. (e.g. <code>v1</code>, <code>apps/v1</code>, <code>batch/v1</code>)</td></tr>
<tr><td><code>resource</code></td><td>The canonical, lowercase, plural name of the parent resource. (e.g. <code>deployments</code>, <code>replicasets</code>, <code>statefulsets</code>)</td></tr>
<tr><td><code>labelSelector</code></td><td>A <code>v1.LabelSelector</code> object. Omit if not used (i.e. Namespace or Names should be used)</td></tr>
<tr><td><code>namespace</code></td><td>Optional. The Namespace to select in</td></tr>
<tr><td><code>names</code></td><td>Optional. A list of strings, representing individual objects to return</td></tr>
</tbody></table>
<p><strong>Important note</strong>
Please note that you can specify label selector or Namespace/Names, not both in the same <code>ResourceRule</code>.</p>
<p>If the parent resource is cluster scoped and the related resource is namespaced,
the namespace may be used to restrict which objects to look at. If the parent
resource is namespaced, the related resources must come from the same namespace.
Specifying the namespace is optional, but if specified must match.</p>
<p>Note that your webhook handler must return a response with a status code of <code>200</code>
to be considered successful. Metacontroller will wait for a response for up to the
amount defined in the <a href="api/../api/hook.html#webhook">Webhook spec</a>.</p>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<p>Let's take a look at <a href="api/../examples.html#global-config-map">Global Config Map example</a> custom resource object:</p>
<pre><code class="language-yaml">---
apiVersion: examples.metacontroller.io/v1alpha1
kind: GlobalConfigMap
metadata:
  name: globalsettings
spec:
  sourceName: globalsettings
  sourceNamespace: global
</code></pre>
<p>it tells that we would like to have <code>globalsettings</code> ConfigMap from <code>global</code> namespace
present in each namespace.</p>
<p>The customize hook request will looks like :</p>
<pre><code class="language-json">{
    'controller': '...',
    'parent': '...'
}
</code></pre>
<p>and we need to extract information identyfying source ConfigMap.</p>
<p>Controller returns :</p>
<pre><code class="language-json">[
    {
        'apiVersion': 'v1',
        'resource': 'configmaps',
        'namespace': ${parent['spec']['sourceNamespace']},
        'names': [${parent['spec']['sourceName']}]
    }, {
        'apiVersion': 'v1',
        'resource': 'namespaces',
        'labelSelector': {}
    }
]
</code></pre>
<p>The first <code>RelatedRule</code> describes that given configmap should be returned (it will be used as souce for our propagation).</p>
<p>The second <code>RelatedRule</code> describes that we want to recieve also all namespaces in the cluster (<code>'labelSelector': {}</code> means - select all objects).</p>
<p>With those rules, call to the <code>sync</code> hook will have non empty <code>related</code> field (if resources exists in the cluster), in which all objects matching given criteria will be present.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hook-1"><a class="header" href="#hook-1">Hook</a></h1>
<p>This page describes how hook targets are defined in various APIs.</p>
<p>Each hook that you define as part of using one of the hook-based APIs
has the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="api/hook.html#webhook">webhook</a></td><td>Specify how to invoke this hook over HTTP(S).</td></tr>
</tbody></table>
<ul>
<li><a href="api/hook.html#example">Example</a></li>
<li><a href="api/hook.html#webhook">Webhook</a>
<ul>
<li><a href="api/hook.html#service-reference">Service Reference</a></li>
<li><a href="api/hook.html#etag-reference">Etag Reference</a></li>
</ul>
</li>
</ul>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><code class="language-yaml">webhook:
  url: http://my-controller-svc/sync
</code></pre>
<h2 id="webhook"><a class="header" href="#webhook">Webhook</a></h2>
<p>Each Webhook has the following fields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="api/hook.html#etag-reference">etag</a></td><td>A configuration for etag logic</td></tr>
<tr><td>url</td><td>A full URL for the webhook (e.g. <code>http://my-controller-svc/hook</code>). If present, this overrides any values provided for <code>path</code> and <code>service</code>.</td></tr>
<tr><td>timeout</td><td>A duration (in the format of Go's time.Duration) indicating the time that Metacontroller should wait for a resserviceponse. If the webhook takes longer than this time, the webhook call is aborted and retried later. Defaults to 10s.</td></tr>
<tr><td>path</td><td>A path to be appended to the accompanying <code>service</code> to reach this hook (e.g. <code>/hook</code>). Ignored if full <code>url</code> is specified.</td></tr>
<tr><td><a href="api/hook.html#service-reference">service</a></td><td>A reference to a Kubernetes Service through which this hook can be reached.</td></tr>
</tbody></table>
<h3 id="service-reference"><a class="header" href="#service-reference">Service Reference</a></h3>
<p>Within a <code>webhook</code>, the <code>service</code> field has the following subfields:</p>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td>The <code>metadata.name</code> of the target Service.</td></tr>
<tr><td>namespace</td><td>The <code>metadata.namespace</code> of the target Service.</td></tr>
<tr><td>port</td><td>The port number to connect to on the target Service. Defaults to <code>80</code>.</td></tr>
<tr><td>protocol</td><td>The protocol to use for the target Service. Defaults to <code>http</code>.</td></tr>
</tbody></table>
<h3 id="etag-reference"><a class="header" href="#etag-reference">Etag Reference</a></h3>
<p>More details in <a href="https://www.rfc-editor.org/rfc/rfc7232">rfc7232</a>.</p>
<p>Etag is a hash of response content, controller that supports etag notion should add &quot;ETag&quot; header to each 200 response.
Metacontrollers that support &quot;ETag&quot; should send the &quot;If-None-Match&quot; header with value of ETag of cached content.
If content has not changed, controller should reply with &quot;304 Not modified&quot; or &quot;412 Precondition Failed&quot;, otherwise it sends 200 with &quot;ETag&quot; header.</p>
<p>This logic helps save traffic and CPU time on webhook processing.</p>
<p>Within a <code>webhook</code>, the <code>eTag</code> field has the following subfields:</p>
<pre><code>Enabled             *bool  `json:&quot;enabled,omitempty&quot;`
CacheTimeoutSeconds *int32 `json:&quot;cacheTimeoutSeconds,omitempty&quot;`
CacheCleanupSeconds *int32 `json:&quot;cacheCleanupSeconds,omitempty&quot;`
</code></pre>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td>Enabled</td><td>true or false. Default is false</td></tr>
<tr><td>CacheTimeoutSeconds</td><td>Time in seconds after which ETag cache record is forgotten</td></tr>
<tr><td>CacheCleanupSeconds</td><td>How often ETag is running garbage collector to cleanup forgotten records</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-docs"><a class="header" href="#design-docs">Design Docs</a></h1>
<h2 id="mapcontroller"><a class="header" href="#mapcontroller"><a href="./design/map-controller.html">MapController</a></a></h2>
<p>This is a design proposal for an API called MapController.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapcontroller-1"><a class="header" href="#mapcontroller-1">MapController</a></h1>
<p>This is a design proposal for an API called MapController.</p>
<ul>
<li><a href="design/map-controller.html#background">Background</a></li>
<li><a href="design/map-controller.html#problem-statement">Problem Statement</a></li>
<li><a href="design/map-controller.html#proposed-solution">Proposed Solution</a></li>
<li><a href="design/map-controller.html#alternatives-considered">Alternatives Considered</a>
<ul>
<li><a href="design/map-controller.html#friend-resources">Friend Resources</a></li>
<li><a href="design/map-controller.html#decorator-resources">Decorator Resources</a></li>
</ul>
</li>
<li><a href="design/map-controller.html#example">Example</a></li>
<li><a href="design/map-controller.html#api">API</a>
<ul>
<li><a href="design/map-controller.html#parent-resource">Parent Resource</a></li>
<li><a href="design/map-controller.html#input-resources">Input Resources</a></li>
<li><a href="design/map-controller.html#output-resources">Output Resources</a></li>
<li><a href="design/map-controller.html#detached-outputs">Detached Outputs</a></li>
<li><a href="design/map-controller.html#status-aggregation">Status Aggregation</a></li>
</ul>
</li>
<li><a href="design/map-controller.html#hooks">Hooks</a>
<ul>
<li><a href="design/map-controller.html#map-hook">Map Hook</a>
<ul>
<li><a href="design/map-controller.html#map-hook-request">Map Hook Request</a></li>
<li><a href="design/map-controller.html#map-hook-response">Map Hook Response</a></li>
</ul>
</li>
<li><a href="design/map-controller.html#tombstone-hook">Tombstone Hook</a>
<ul>
<li><a href="design/map-controller.html#tombstone-hook-request">Tombstone Hook Request</a></li>
<li><a href="design/map-controller.html#tombstone-hook-response">Tombstone Hook Response</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Metacontroller APIs are meant to represent common controller patterns.
The goal of these APIs as a group is to strike a balance between being flexible
enough to handle unforeseen use cases and providing strong enough &quot;rails&quot; to
avoid pushing the hard parts onto users.
The initial strategy is to target controller patterns that are analogous to
proven design patterns in functional or object-oriented programming.</p>
<p>For example, CompositeController lets you define the canonical relationship
between some object (the parent node) and the objects that are directly under it
in an ownership tree (child nodes).
This is analogous to the <a href="https://en.wikipedia.org/wiki/Composite_pattern">Composite pattern</a> in that it lets you manage a
group of child objects as if were one object (by manipulating only the parent
object).</p>
<p>Similarly, DecoratorController lets you add new child nodes to a parent node
that already has some other behavior.
This is analogous to the <a href="https://en.wikipedia.org/wiki/Decorator_pattern">Decorator pattern</a> in that it lets you dynamically
wrap new behavior around select instances of an existing object type without
having to create a new type.</p>
<h2 id="problem-statement"><a class="header" href="#problem-statement">Problem Statement</a></h2>
<p>The problem that MapController addresses is that neither CompositeController nor
DecoratorController allow you to make decisions based on objects that
aren't owned by the particular parent object being processed.
That's because in the absence of a parent-child relationship, there are
arbitrarily many ways you could pick what other objects you want to look at.</p>
<p>To avoid having to send every object in a given resource (e.g. every Pod)
on every hook invocation, there must be some way to tell Metacontroller which
objects you need to see (that you don't own) to compute your desired state.
Rather than try to embed various options for declaring these relationships
(object name? label selector? field selector?) into each existing Metacontroller
API, the goal of MapController is to provide a solution that's orthogonal to the
existing APIs.</p>
<p>In other words, we attempt to separate the task of looking at non-owned objects
(MapController) from the task of defining objects that are composed of other
objects (CompositeController) so that users can mix and match these APIs
(and future APIs) as needed without being limited to the precise scenarios we're
able to anticipate.</p>
<h2 id="proposed-solution"><a class="header" href="#proposed-solution">Proposed Solution</a></h2>
<p>MapController lets you define a collection of objects owned by a parent object,
where each child object is generated by some mapping from a non-owned object.
This is analogous to the general concept of a <a href="https://en.wikipedia.org/wiki/Map_(higher-order_function)">map function</a> in that it calls
your hook for each object in some input list (of non-owned objects), and creates
an output list (of child objects) containing the results of each call.</p>
<p>A single <code>sync</code> pass for a MapController roughly resembles this pseudocode:</p>
<pre><code class="language-python">def sync_map_controller():
  input_list = get_matching_objects(input_resource, input_selector)
  output_list = list()

  foreach input_object in input_list:
    output_list.append(map_hook(input_object))

  reconcile_objects(output_list)
</code></pre>
<p>where <code>map_hook()</code> is the only code that the MapController user writes,
as a lambda hook.</p>
<p>In general, MapController addresses use cases that can be described as,
&quot;For every matching X object that already exists, I want to create some number
of Y objects according to the parameters stored in the parent object.&quot;</p>
<h2 id="alternatives-considered"><a class="header" href="#alternatives-considered">Alternatives Considered</a></h2>
<h3 id="friend-resources"><a class="header" href="#friend-resources">Friend Resources</a></h3>
<p>Add a new type of &quot;non-child&quot; resource to CompositeController called
&quot;friend resources&quot;.
Along with all the matching children, we would also send all matching objects of
the friend resource types to the sync hook request.</p>
<p>Matching would be determined with the parent's selector, just like for children.
However, we would not require friends to have a ControllerRef pointing to the
parent (the parent-friend relationship is non-exclusive), and the parent will
not attempt to adopt friends.</p>
<p>The sync hook response would not contain friends, because we don't want to force
you to list a desired state for all your friends every time.
This means you cannot edit or delete your friends.</p>
<p>This approach was not chosen because:</p>
<ol>
<li>We have to send the entire list of matching friends as one big hook request.
This complicates the user's hook code because they probably need to loop over
each friend.
It's also inefficient for patterns like <em>&quot;for every X (where there are a lot
of X's), create a Y&quot;</em> since we have to sync every X if any one of them
changes, and we can't process any of them in parallel.</li>
<li>It's tied in with the CompositeController API, and doing something similar
for other APIs like DecoratorController would require both duplicated and
different effort (see <a href="design/map-controller.html#decorator-resources">Decorator Resources</a>).</li>
<li>It either forces you to use the same selector to find friends as you use to
claim children, or it complicates the API with multiple selectors for
different resources, which becomes difficult to reason about.</li>
<li>If we force the same selector to apply to both friends and children,
we also force you to explicitly specify a meaningful set of labels.
You can't use selector generation (<code>controller-uid: ###</code>) for cases when you
don't need orphaning and adoption; your friends won't match that selector.</li>
</ol>
<h3 id="decorator-resources"><a class="header" href="#decorator-resources">Decorator Resources</a></h3>
<p>Add a new type of resource to DecoratorController called a decorator resource,
which contains objects that inform the behavior of the decorator.
This would allow controllers that look at non-owned resources as part of
computing the desired state of their children.</p>
<p>In particular, you could use DecoratorController to create attachments
(extra children) on a parent object, while basing your desired state on
information in another object (the decorator resource) that is not owned by that
parent.</p>
<p>This approach was not chosen because:</p>
<ol>
<li>It's unclear how we would &quot;link&quot; objects of the decorator resource to
particular parent objects being processed.
Would we apply the parent selector to find decorator objects?
Or apply a selector inside the decorator object to determine if it matches
the parent object?
Whatever we choose, it will likely be unintuitive and confusing for users.</li>
<li>It's unclear what should happen if multiple decorator objects match a single
parent object.
We could send multiple decorator objects to the hook, but that just passes
the complexity on to the user.</li>
<li>It's unclear whether decorator objects are expected to take part in ownership
of the objects created.
Depending on the use case, users might want attachments to be owned by just
the parent, just the decorator, or both.
This configuration adds to the cognitive overhead of using the API,
and there's no one default that's more intuitive than the others.</li>
</ol>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<p>The example use case we'll consider in this doc is a controller called
SnapshotSchedule that creates periodic backups of PVCs with the VolumeSnapshot
API.
Notice that it's natural to express this in the form we defined above:
&quot;For every matching PVC, I want to create some VolumeSnapshot objects.&quot;</p>
<p>CompositeController doesn't fit this use case because the PVCs are created and
potentially owned by something other than the SnapshotSchedule object.
For example, the PVCs might have been created by a StatefulSet.
Instead of creating PVCs, we want to look at all the PVCs that already exist and
take action on certain ones.</p>
<p>DecoratorController doesn't fit this use case because it doesn't make sense for
the VolumeSnapshots we create to be owned by the PVC from which the snapshot was
taken.
The lifecycle of a VolumeSnapshot has to be separate from the PVC because the
whole point is that you should be able to recover the data if the PVC goes away.
Since the PVC doesn't own the VolumeSnapshots, it doesn't make sense to think of
the snapshots as a decoration on PVC (an additional feature of the PVC API).</p>
<p>An instance of SnapshotSchedule might look like this:</p>
<pre><code class="language-yaml">apiVersion: snapshot.k8s.io/v1
kind: SnapshotSchedule
metadata:
  name: my-app-snapshots
spec:
  snapshotInterval: 6h
  snapshotTTL: 10d
  selector:
    matchLabels:
      app: my-app
</code></pre>
<p>It contains a selector that determines which PVCs this schedule applies to,
and some parameters that determine how often to take snapshots, as well as when
to retire old snapshots.</p>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>Below is a sample MapController spec that could be used to implement the
SnapshotSchedule controller:</p>
<pre><code class="language-yaml">apiVersion: metacontroller.k8s.io/v1alpha1
kind: MapController
metadata:
  name: snapshotschedule-controller
spec:
  parentResource:
    apiVersion: snapshot.k8s.io/v1
    resource: snapshotschedules
  inputResources:
  - apiVersion: v1
    resource: persistentvolumeclaims
  outputResources:
  - apiVersion: volumesnapshot.external-storage.k8s.io/v1
    resource: volumesnapshots
  resyncPeriodSeconds: 5
  hooks:
    map:
      webhook:
        url: http://snapshotschedule-controller.metacontroller/map
    tombstone:
      webhook:
        url: http://snapshotschedule-controller.metacontroller/tombstone
</code></pre>
<h3 id="parent-resource-1"><a class="header" href="#parent-resource-1">Parent Resource</a></h3>
<p>The parent resource is the SnapshotSchedule itself, and anything this controller
creates will be owned by this parent.
The schedule thus acts like a bucket containing snapshots: if you delete the
schedule, the snapshots inside it will go away too, unless you specify to orphan
them as part of the delete operation (e.g. with <code>--cascade=false</code> when using
<code>kubectl delete</code>).
Notably, this ties the lifecycles of snapshots to the reason they exist
(the backup policy that the user defined), rather than tying them to the entity
that they are about (the PVC).</p>
<h3 id="input-resources"><a class="header" href="#input-resources">Input Resources</a></h3>
<p>The input resources (in this case just PVC) are the inputs to the conceptual
&quot;map&quot; function.
We allow multiple input resources because users might want to write a controller
that performs the same action for several different input types.
We shouldn't force them to create multiple MapControllers with largely identical
behavior.</p>
<p>The duck-typed <code>spec.selector</code> field (assumed to be <code>metav1.LabelSelector</code>) in
the parent object is used to filter which input objects to process.
If the selector is empty, we will process all objects of the input types in the
same namespace as the parent.</p>
<p>We will also ignore input objects whose controllerRef points to the particular
parent object being processed.
That would imply that the same resource (e.g. ConfigMap) is listed as both an
input and an output in a given MapController spec.
This allows use cases such as generating ConfigMaps from other ConfigMaps by
doing some transformation on the data, while protecting against accidental
recursion if the label selector is chosen poorly.</p>
<p>If there are multiple input resources, they are processed independently, with no
attempt to correlate them.
That is, the <a href="design/map-controller.html#map-hook">map hook</a> will still be called with only a single input object
each time, although the kind of that object might be different from one call to
the next.</p>
<h3 id="output-resources"><a class="header" href="#output-resources">Output Resources</a></h3>
<p>The output resources (in this case just VolumeSnapshot) are the types of objects
that the user intends to create and hold in the conceptual &quot;bucket&quot; that the
parent object represents.
We allow multiple output resources because users might think of their controller
as spitting out a few different things.
We shouldn't force them to create a CompositeController too just so they can
emit multiple outputs, especially if those outputs are not conceptually part of
one larger whole.</p>
<p>For a given input object, the user can generate any number of output objects.
We will tag those output objects in some way to associate them with
the object that we sent as input.
The tag makes it possible to group those objects and send them along with future
<a href="design/map-controller.html#map-hook-request">map hook requests</a>.</p>
<p>In pseudocode, a <code>sync</code> pass could be thought of like the following:</p>
<pre><code class="language-go">// Get all matching objects from all input resources.
inputObjects := []Object{}
for _, inputResource := range inputResources {
  inputObjects = append(inputObjects, getMatchingObjects(inputResource, parentSelector)...)
}
// Call the once hook for each input object.
for _, inputObject := range inputObjects {
  // Compute some opaque string identifying this input object.
  mapKey := makeMapKey(inputObject)

  // Gather observed objects of the output resources that are tagged with this key.
  observedOutputs := []Object{}
  for _, outputResource := range outputResources {
    // Gather all outputs owned by this parent.
    allOutputs := getOwnedObjects(outputResource, parent)
    // Filter to only those tagged for this input.
    observedOutputs = append(observedOutputs, filterByMapKey(allOutputs, mapKey)...)
  }

  // Call user's map hook, passing observed state.
  mapResult := mapHook(parent, inputObject, observedOutputs)
  for _, obj := range mapResult.Outputs {
    // Tag outputs to identify which input they came from.
    setMapKey(obj, mapKey)
  }
  // Manage child objects by reconciling observed and desired outputs.
  manageChildren(observedOutputs, mapResult.Outputs)
}
</code></pre>
<h3 id="detached-outputs"><a class="header" href="#detached-outputs">Detached Outputs</a></h3>
<p>If an input object disappears, we may find that the parent owns one or more
output objects that are tagged as having been generated from an input object
that no longer exists.
Note that this does not mean these objects have been orphaned, in the sense of
having no ownerRef/controllerRef; the controllerRef will still point to the
parent object.
It's only our MapController-specific &quot;tag&quot; that has become a broken link.</p>
<p>By default, we will delete any such <em>detached outputs</em> so that controller
authors don't have to think about them.
However, the SnapshotSchedule example shows that sometimes it will be important
to give users control over what happens to these objects.
In that example, the user would want to keep detached VolumeSnapshots since they
might be needed to restore the now-missing PVC.</p>
<p>We could offer a declarative knob to either always delete detached outputs,
or always keep them, but that would be awkwardly restrictive.
The controller author would have fine-grained control over the lifecycle of
&quot;live&quot; outputs, but would suddenly lose that control when the outputs become
detached.</p>
<p>Instead, we propose to define an optional <a href="design/map-controller.html#tombstone-hook">tombstone hook</a> that sends
information about a particular group of detached outputs (belonging to a
particular input object that is now gone), and asks the user to decide which
ones to keep.
For example, SnapshotSchedule would likely want to keep detached VolumeSnapshots
around until the usual expiry timeout.</p>
<p>For now, we will not allow the hook to edit detached outputs because we don't
want to commit to sending the body of the missing input object, since it
may not be available.
Without that input object, the hook author presumably wouldn't have enough
information to decide on an updated desired state anyway.
We can reexamine this if users come up with compelling use cases.</p>
<h3 id="status-aggregation"><a class="header" href="#status-aggregation">Status Aggregation</a></h3>
<p>One notable omission from the map hook, as compared with the sync hook from
CompositeController, is that the user does not return any status object.
That's because each map hook invocation only sends enough context to process a
single input object and its associated output objects.
The hook author therefore doesn't have enough information to compute the overall
status of the parent object.</p>
<p>We could define another hook to which we send all inputs and outputs for a given
parent, and ask the user to return the overall status.
However, that would defeat one of the main goals of MapController because such a
monolithic hook request could get quite large for the type of use cases we
expect for a controller that says, &quot;do this for every X,&quot; and also because that
would place the burden of aggregating status across the whole collection onto
the user.</p>
<p>Instead, Metacontroller will compute an aggregated status for the collection
based on some generic rules:</p>
<p>For each input resource, we will report the number of matching objects we
observed as a status field on the parent object, named after the plural
resource name.</p>
<p>The exact format will be an implementation detail, but for example it might
look like:</p>
<pre><code class="language-yaml">status:
  inputs:
    persistentvolumeclaims:
      total: 20
  ...
</code></pre>
<p>For each output resource, we will report the total number of objects owned by
this parent across all map keys.
In addition, we will automatically aggregate conditions found on output objects,
and report how many objects we own with that condition set to <code>True</code>.</p>
<p>For example:</p>
<pre><code class="language-yaml">status:
  ...
  outputs:
    volumesnapshots:
      total: 100
      ready: 97
  ...
</code></pre>
<h2 id="hooks-2"><a class="header" href="#hooks-2">Hooks</a></h2>
<h3 id="map-hook"><a class="header" href="#map-hook">Map Hook</a></h3>
<p>We call the map hook to translate an input object into zero or more output
objects.</p>
<h4 id="map-hook-request"><a class="header" href="#map-hook-request">Map Hook Request</a></h4>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>controller</code></td><td>The whole MapController object, like what you might get from <code>kubectl get mapcontroller &lt;name&gt; -o json</code>.</td></tr>
<tr><td><code>parent</code></td><td>The parent object, like what you might get from <code>kubectl get &lt;parent-resource&gt; &lt;parent-name&gt; -o json</code>.</td></tr>
<tr><td><code>mapKey</code></td><td>An opaque string that uniquely identifies the group of outputs that belong to this input object.</td></tr>
<tr><td><code>input</code></td><td>The input object, like what you might get from <code>kubectl get &lt;input-resource&gt; &lt;input-name&gt; -o json</code>.</td></tr>
<tr><td><code>outputs</code></td><td>An associative array of output objects that the parent already created for the given input object.</td></tr>
</tbody></table>
<h4 id="map-hook-response"><a class="header" href="#map-hook-response">Map Hook Response</a></h4>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>outputs</code></td><td>A list of JSON objects representing all the desired outputs for the given input object.</td></tr>
</tbody></table>
<h3 id="tombstone-hook"><a class="header" href="#tombstone-hook">Tombstone Hook</a></h3>
<p>We call the tombstone hook, if defined, to ask whether we should keep any of a
group of output objects whose corresponding input object is gone.
If no tombstone hook is defined, we will always delete any such orphans as soon
as the input object disappears.</p>
<h4 id="tombstone-hook-request"><a class="header" href="#tombstone-hook-request">Tombstone Hook Request</a></h4>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>controller</code></td><td>The whole MapController object, like what you might get from <code>kubectl get mapcontroller &lt;name&gt; -o json</code>.</td></tr>
<tr><td><code>parent</code></td><td>The parent object, like what you might get from <code>kubectl get &lt;parent-resource&gt; &lt;parent-name&gt; -o json</code>.</td></tr>
<tr><td><code>mapKey</code></td><td>An opaque string that uniquely identifies the group of outputs that belong to this input object.</td></tr>
<tr><td><code>outputs</code></td><td>An associative array of output objects that the parent already created for the given input object.</td></tr>
</tbody></table>
<h4 id="tombstone-hook-response"><a class="header" href="#tombstone-hook-response">Tombstone Hook Response</a></h4>
<table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>outputs</code></td><td>A list of output objects to keep, even though the associated input object is gone. All other outputs belonging to this input will be deleted.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributor-guide"><a class="header" href="#contributor-guide">Contributor Guide</a></h1>
<p>This section contains information for people who want to hack on or
contribute to Metacontroller.</p>
<p>See the <a href="./guide.html">User Guide</a> if you just want to use Metacontroller.</p>
<h2 id="github"><a class="header" href="#github">GitHub</a></h2>
<ul>
<li><a href="https://www.github.com/metacontroller/metacontroller/issues">Issues</a></li>
<li><a href="https://www.github.com/metacontroller/metacontroller/projects">Project Boards</a></li>
</ul>
<!---* [Roadmap](https://www.github.com/metacontroller/metacontroller/issues/9)-->
<h2 id="building"><a class="header" href="#building"><a href="./contrib/build.html">Building</a></a></h2>
<p>The page describes how to build Metacontroller for yourself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-1"><a class="header" href="#building-1">Building</a></h1>
<p>The page describes how to build Metacontroller for yourself.</p>
<ul>
<li><a href="contrib/build.html#local-build-and-development">Local build and development</a></li>
<li><a href="contrib/build.html#documentation-build">Documentation build</a></li>
<li><a href="contrib/build.html#tests">Tests</a>
<ul>
<li><a href="contrib/build.html#unit-tests">Unit Tests</a></li>
<li><a href="contrib/build.html#integration-tests">Integration Tests</a></li>
<li><a href="contrib/build.html#end-to-end-tests">End-to-End Tests</a></li>
</ul>
</li>
</ul>
<p>First, check out the code:</p>
<pre><code class="language-sh"># If you're going to build locally, make sure to
# place the repo according to the Go import path:
#   $GOPATH/src/metacontroller.io
cd $GOPATH/src
git clone git@github.com:metacontroller/metacontroller.git metacontroller
cd metacontroller
</code></pre>
<p>Then you can build a <code>metacontroller</code> binary like so:</p>
<pre><code class="language-sh">make build
</code></pre>
<h2 id="local-build-and-development"><a class="header" href="#local-build-and-development">Local build and development</a></h2>
<p>Check <a href="contrib/./debug.html">debug section</a></p>
<h2 id="documentation-build"><a class="header" href="#documentation-build">Documentation build</a></h2>
<p>Documentation is generated from <code>.md</code> files with <a href="https://github.com/rust-lang/mdBook">mdbook</a>.
To generate documentation, you need to install:</p>
<ul>
<li>mdbook</li>
<li>mdbook plugins:
<ul>
<li><a href="https://crates.io/crates/mdbook-linkcheck">linkcheck</a> - verifies link corectness</li>
<li><a href="https://crates.io/crates/mdbook-toc">toc</a> - creates TOC's - table of content</li>
<li><a href="https://crates.io/crates/mdbook-graphviz">graphviz</a> - generation of dot diagrams</li>
<li><a href="https://crates.io/crates/mdbook-open-on-gh">open-on-gh</a> - adds open-on-gh link</li>
</ul>
</li>
<li>graphviz</li>
</ul>
<p>To generate documentation</p>
<ul>
<li><code>cd docs</code></li>
<li><code>mdbook build</code>
There will be <code>book</code> folder generated with html content.</li>
</ul>
<p>You can also use <code>mdbook serve</code> to expose documentation on <code>http://localhost:3000</code>.</p>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>To run tests, first make sure you can successfully complete a <a href="contrib/build.html#local-build">local build</a>.</p>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<p>Unit tests in Metacontroller focus on code that does some kind of non-trival
local computation without depending on calls to remote servers -- for example,
the <code>./dynamic/apply</code> package.</p>
<p>Unit tests live in <code>_test.go</code> files alongside the code that they test.
To run only unit tests (excluding <a href="contrib/build.html#integration-tests">integration tests</a>)
for all Metacontroller packages, use this command:</p>
<pre><code class="language-sh">make unit-test
</code></pre>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<p>Integration tests in Metacontroller focus on verifying behavior at the level of
calls to remote services like user-provided webhooks and the Kubernetes API server.
Since Metacontroller's job is ultimately to manipulate Kubernetes API objects in
response to other Kubernetes API objects, most of the important features or
behaviors of Metacontroller can and should be tested at this level.</p>
<p>In the integration test environment, we start a standalone <code>kube-apiserver</code> to
serve the REST APIs, and an <code>etcd</code> instance to back it.
We do <em>not</em> run any kubelets (Nodes), nor any controllers other than
Metacontroller.
This makes it easy for tests to control exactly what API objects Metacontroller
sees without interference from the normal controller for each API,
and also greatly reduces the requirements to run tests.</p>
<p>Other than the Metacontroller codebase, all you need to run integration tests
is to download a few binaries from a Kubernetes release.
You can run the following script from the <code>test/integration</code> directory in to
order to fetch the versions of these binaries currently used in continuous
integration, and place them in <code>./hack/bin</code>:</p>
<pre><code class="language-sh">hack/get-kube-binaries.sh
</code></pre>
<p>You can then run the integration tests with this command, which will
automatically set the PATH to include <code>./hack/bin</code>:</p>
<pre><code class="language-sh">make integration-test
</code></pre>
<p>Unlike unit tests, integration tests do not live alongside the code they test,
but instead are gathered in <code>./test/integration/...</code>.
This makes it easier to run them separately, since they require a special
environment, and also enforces that they test packages at the level of their
public interfaces.</p>
<h3 id="end-to-end-tests"><a class="header" href="#end-to-end-tests">End-to-End Tests</a></h3>
<p>End-to-end tests in Metacontroller focus on verifying example workflows that we
expect to be typical for end users. That is, we run the same <code>kubectl</code> commands
that a human might run when using Metacontroller.</p>
<p>Since these tests verify end-to-end behavior, they require a fully-functioning
Kubernetes cluster.
Before running them, you should have <code>kubectl</code> in your PATH, and it should be
configured to talk to a suitable, empty test cluster that has had the
Metacontroller manifests applied.</p>
<p>Then you can run the end-to-end tests against your cluster with the following:</p>
<pre><code class="language-sh">cd examples
./test.sh
</code></pre>
<p>This will run all the end-to-end tests in series, and print the location of a
log file containing the output of the latest test that was run.</p>
<p>You can also run each test individually, which will show the output as it runs.
For example:</p>
<pre><code class="language-sh">cd examples/bluegreen
./test.sh
</code></pre>
<p>Note that currently our continuous integration only runs unit and integration
tests on PRs, since those don't require a full cluster.
If you have access to a suitable test cluster, you can help speed up review of
your PR by running these end-to-end tests yourself to see if they catch anything.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-development-and-debugging"><a class="header" href="#local-development-and-debugging">Local development and debugging</a></h1>
<p>Tips and tricks for contributors</p>
<ul>
<li><a href="contrib/debug.html#local-run-of-metacontroller">Local run of metacontroller</a>
<ul>
<li><a href="contrib/debug.html#development-build">Development build</a></li>
<li><a href="contrib/debug.html#debug-build">Debug build</a></li>
</ul>
</li>
</ul>
<h2 id="local-run-of-metacontroller"><a class="header" href="#local-run-of-metacontroller">Local run of metacontroller</a></h2>
<p>There are different flavours of manifests shipped to help with local development:</p>
<ul>
<li>manifests/dev</li>
<li>manifests/debug</li>
</ul>
<h3 id="development-build"><a class="header" href="#development-build">Development build</a></h3>
<p>The main difference it that image defined in manifest is <code>localhost/metacontroller:dev</code>, therefore:</p>
<ul>
<li>apply dev manifests - <code>kubectl apply -k manifests/dev</code></li>
<li>build docker image with command - <code>make image</code> - this will compile the binary and build the container image</li>
<li>load image into cluster (i.e. <code>kind load docker-image localhost/metacontroller:dev</code> in kind)</li>
<li>restart pod (i.e. <code>kubectl delete pod/metacontroller-0 --namespace metacontroller</code>)</li>
</ul>
<h3 id="debug-build"><a class="header" href="#debug-build">Debug build</a></h3>
<p>Debug requires building go sources in special way, which is done with <code>make build_debug</code>; the following image
built with the <code>Dockerfile.debug</code> dockerfile will then add it to the debug Docker image:</p>
<ul>
<li>apply debug manifests - <code>kubectl apply -k manifests/debug</code></li>
<li>build debug binary and image - <code>make image_debug</code></li>
<li>load image into cluster (i.e. <code>kind load docker-image localhost/metacontroller:debug</code> in kind)</li>
<li>restart pod</li>
<li>on startup, <code>go</code> process will wait for debugger on port 40000</li>
<li>port forward port 40000 from container into localhost, i.e. <code>kubectl port-forward metacontroller-0 40000:40000</code></li>
<li>attach <code>go</code> debugger to port 40000 on localhost</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
